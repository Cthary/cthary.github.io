<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warhammer 40k Combat Simulator v2.1</title>
    
    <!-- Preconnect for performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <!-- Google Fonts with font-display: swap for performance -->
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@300;400;500;600;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    
    <!-- Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
        /* ===== CSS DESIGN SYSTEM - VERSION 2.1 ===== */
        
        /* CSS Custom Properties (Design Tokens) */
        :root {
            /* Color Palette - Warhammer 40k Theme */
            --primary-bg: #0a0a0a;
            --secondary-bg: #1a1a1a;
            --panel-bg: #2a2a2a;
            --accent-bg: #3a3a3a;
            
            --text-primary: #e8e8e8;
            --text-secondary: #b8b8b8;
            --text-accent: #d4af37;
            --text-muted: #888888;
            
            --primary-gold: #d4af37;
            --secondary-gold: #b8941f;
            --accent-gold: #f4d03f;
            --dark-gold: #8b7500;
            
            --error-color: #e74c3c;
            --warning-color: #f39c12;
            --success-color: #27ae60;
            --info-color: #3498db;
            
            --border-color: #404040;
            --border-accent: #606060;
            --border-light: #808080;
            
            /* Typography Scale */
            --font-family-primary: 'Exo 2', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-family-display: 'Orbitron', monospace;
            
            --font-size-xs: 0.75rem;
            --font-size-sm: 0.875rem;
            --font-size-base: 1rem;
            --font-size-lg: 1.125rem;
            --font-size-xl: 1.25rem;
            --font-size-2xl: 1.5rem;
            --font-size-3xl: 1.875rem;
            --font-size-4xl: 2.25rem;
            
            --font-weight-light: 300;
            --font-weight-normal: 400;
            --font-weight-medium: 500;
            --font-weight-semibold: 600;
            --font-weight-bold: 700;
            
            --line-height-tight: 1.25;
            --line-height-normal: 1.5;
            --line-height-relaxed: 1.75;
            
            /* Spacing Scale */
            --space-xs: 0.25rem;
            --space-sm: 0.5rem;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --space-xl: 2rem;
            --space-2xl: 3rem;
            --space-3xl: 4rem;
            
            /* Border Radius */
            --radius-sm: 0.125rem;
            --radius-md: 0.375rem;
            --radius-lg: 0.5rem;
            --radius-xl: 0.75rem;
            --radius-2xl: 1rem;
            --radius-full: 9999px;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4), 0 2px 4px -1px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.4);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.6), 0 10px 10px -5px rgba(0, 0, 0, 0.3);
            
            /* Transitions */
            --transition-fast: 150ms ease-in-out;
            --transition-normal: 250ms ease-in-out;
            --transition-slow: 350ms ease-in-out;
            
            /* Animation Curves */
            --ease-out-cubic: cubic-bezier(0.33, 1, 0.68, 1);
            --ease-in-out-cubic: cubic-bezier(0.65, 0, 0.35, 1);
            
            /* Z-index Scale */
            --z-dropdown: 1000;
            --z-sticky: 1020;
            --z-fixed: 1030;
            --z-modal-backdrop: 1040;
            --z-modal: 1050;
            --z-popover: 1060;
            --z-tooltip: 1070;
        }
        
        /* ===== RESET & BASE STYLES ===== */
        
        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }
        
        body {
            font-family: var(--font-family-primary);
            font-size: var(--font-size-base);
            line-height: var(--line-height-normal);
            color: var(--text-primary);
            background: linear-gradient(135deg, var(--primary-bg) 0%, var(--secondary-bg) 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* ===== ACCESSIBILITY & SCREEN READER ===== */
        
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        .skip-link {
            position: absolute;
            top: -40px;
            left: 6px;
            background: var(--primary-gold);
            color: var(--primary-bg);
            padding: 8px;
            text-decoration: none;
            border-radius: var(--radius-md);
            z-index: var(--z-tooltip);
            font-weight: var(--font-weight-medium);
            transition: top var(--transition-fast);
        }
        
        .skip-link:focus {
            top: 6px;
        }
        
        /* Focus styles for better accessibility */
        :focus-visible {
            outline: 2px solid var(--primary-gold);
            outline-offset: 2px;
            border-radius: var(--radius-sm);
        }
        
        /* ===== TYPOGRAPHY ===== */
        
        h1, h2, h3, h4, h5, h6 {
            font-family: var(--font-family-display);
            font-weight: var(--font-weight-bold);
            line-height: var(--line-height-tight);
            margin-bottom: var(--space-md);
            color: var(--text-accent);
        }
        
        h1 { font-size: var(--font-size-4xl); }
        h2 { font-size: var(--font-size-3xl); }
        h3 { font-size: var(--font-size-2xl); }
        h4 { font-size: var(--font-size-xl); }
        h5 { font-size: var(--font-size-lg); }
        h6 { font-size: var(--font-size-base); }
        
        p {
            margin-bottom: var(--space-md);
            color: var(--text-secondary);
        }
        
        /* ===== LAYOUT COMPONENTS ===== */
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--space-lg);
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-xl);
            margin: var(--space-xl) 0;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: var(--space-md);
            }
            
            .main-grid {
                grid-template-columns: 1fr;
                gap: var(--space-lg);
            }
        }
        
        /* ===== CARD COMPONENT ===== */
        
        .card {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-lg);
            overflow: hidden;
            transition: all var(--transition-normal);
        }
        
        .card:hover {
            border-color: var(--border-accent);
            box-shadow: var(--shadow-xl);
        }
        
        .card-header {
            background: linear-gradient(45deg, var(--accent-bg), var(--secondary-bg));
            padding: var(--space-lg) var(--space-xl);
            border-bottom: 1px solid var(--border-color);
        }
        
        .card-title {
            margin: 0;
            display: flex;
            align-items: center;
            gap: var(--space-md);
        }
        
        .card-body {
            padding: var(--space-xl);
        }
        
        .card-footer {
            background: var(--secondary-bg);
            padding: var(--space-lg) var(--space-xl);
            border-top: 1px solid var(--border-color);
        }
        
        /* ===== SITE HEADER ===== */
        
        .site-header {
            text-align: center;
            padding: var(--space-2xl) 0;
            position: relative;
        }
        
        .site-title {
            font-family: var(--font-family-display);
            font-weight: 900;
            font-size: clamp(2rem, 5vw, 4rem);
            background: linear-gradient(45deg, var(--primary-gold), var(--accent-gold));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: var(--space-md);
        }
        
        .site-description {
            font-size: var(--font-size-lg);
            color: var(--text-secondary);
            max-width: 600px;
            margin: 0 auto var(--space-lg);
        }
        
        .version-badge {
            display: inline-block;
            background: linear-gradient(45deg, var(--primary-gold), var(--secondary-gold));
            color: var(--primary-bg);
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-full);
            font-size: var(--font-size-sm);
            font-weight: var(--font-weight-semibold);
            letter-spacing: 0.5px;
        }
        
        /* ===== FORM COMPONENTS ===== */
        
        .form-group {
            margin-bottom: var(--space-lg);
        }
        
        .form-label {
            display: block;
            font-weight: var(--font-weight-medium);
            color: var(--text-primary);
            margin-bottom: var(--space-sm);
            font-size: var(--font-size-sm);
        }
        
        .form-label.required::after {
            content: ' *';
            color: var(--error-color);
            font-weight: var(--font-weight-bold);
        }
        
        .form-input,
        .form-select,
        .form-textarea {
            width: 100%;
            padding: var(--space-md);
            background: var(--secondary-bg);
            border: 2px solid var(--border-color);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-size: var(--font-size-base);
            font-family: inherit;
            transition: all var(--transition-normal);
        }
        
        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: var(--primary-gold);
            box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.1);
        }
        
        .form-input:required,
        .form-select:required {
            border-left: 4px solid var(--error-color);
        }
        
        .form-input:required:valid,
        .form-select:required:valid {
            border-left-color: var(--success-color);
        }
        
        .form-input::placeholder {
            color: var(--text-muted);
        }
        
        /* Form validation states */
        .form-group.has-error .form-input,
        .form-group.has-error .form-select {
            border-color: var(--error-color);
        }
        
        .form-group.has-success .form-input,
        .form-group.has-success .form-select {
            border-color: var(--success-color);
        }
        
        /* ===== BUTTON COMPONENTS ===== */
        
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
            padding: var(--space-md) var(--space-lg);
            background: var(--accent-bg);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: var(--font-size-base);
            font-weight: var(--font-weight-medium);
            font-family: inherit;
            text-decoration: none;
            cursor: pointer;
            transition: all var(--transition-normal);
            min-height: 44px;
            white-space: nowrap;
        }
        
        .btn:hover:not(:disabled) {
            background: var(--panel-bg);
            border-color: var(--border-accent);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, var(--primary-gold), var(--secondary-gold));
            color: var(--primary-bg);
            border-color: var(--primary-gold);
            box-shadow: var(--shadow-md);
        }
        
        .btn-primary:hover:not(:disabled) {
            background: linear-gradient(45deg, var(--secondary-gold), var(--accent-gold));
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .btn-secondary {
            background: var(--secondary-bg);
            color: var(--text-primary);
            border-color: var(--border-color);
        }
        
        .btn-danger {
            background: linear-gradient(45deg, var(--error-color), #dc2626);
            color: white;
            border-color: var(--error-color);
        }
        
        .btn-large {
            padding: var(--space-lg) var(--space-2xl);
            font-size: var(--font-size-lg);
            min-height: 52px;
        }
        
        .btn-icon {
            padding: var(--space-sm);
            min-width: 44px;
            border-radius: var(--radius-full);
        }
        
        .button-group {
            display: flex;
            gap: var(--space-md);
            margin-top: var(--space-lg);
            flex-wrap: wrap;
        }
        
        /* ===== GRID UTILITIES ===== */
        
        .grid {
            display: grid;
            gap: var(--space-lg);
        }
        
        .grid-2 {
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        }
        
        .grid-3 {
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        }
        
        /* ===== LOADING & OVERLAY COMPONENTS ===== */
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: var(--z-modal);
        }
        
        .loading-content {
            background: var(--panel-bg);
            padding: var(--space-2xl);
            border-radius: var(--radius-xl);
            text-align: center;
            box-shadow: var(--shadow-xl);
        }
        
        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--primary-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto var(--space-lg);
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* ===== TOAST NOTIFICATIONS ===== */
        
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            box-shadow: var(--shadow-xl);
            z-index: var(--z-tooltip);
            max-width: 400px;
            animation: slideIn 0.3s ease-out;
        }
        
        .toast-error {
            border-color: var(--error-color);
            background: linear-gradient(45deg, var(--panel-bg), rgba(231, 76, 60, 0.1));
        }
        
        .toast-content {
            display: flex;
            align-items: center;
            gap: var(--space-md);
        }
        
        .toast-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: var(--space-xs);
            margin-left: auto;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* ===== RESPONSIVE DESIGN ===== */
        
        @media (max-width: 768px) {
            .button-group {
                flex-direction: column;
            }
            
            .button-group .btn {
                width: 100%;
            }
            
            .site-title {
                font-size: 2.5rem;
            }
            
            .card-header,
            .card-body,
            .card-footer {
                padding: var(--space-lg);
            }
        }
        
        @media (max-width: 480px) {
            .container {
                padding: var(--space-sm);
            }
            
            .card-header,
            .card-body,
            .card-footer {
                padding: var(--space-md);
            }
        }
        
        /* ===== MATERIAL ICONS ENHANCEMENT ===== */
        
        .material-icons {
            user-select: none;
            font-size: inherit;
        }
        
        /* ===== UTILITY CLASSES ===== */
        
        .text-center { text-align: center; }
        .text-left { text-align: left; }
        .text-right { text-align: right; }
        
        .w-full { width: 100%; }
        .h-full { height: 100%; }
        
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .gap-sm { gap: var(--space-sm); }
        .gap-md { gap: var(--space-md); }
        .gap-lg { gap: var(--space-lg); }
        
        .mt-0 { margin-top: 0; }
        .mb-0 { margin-bottom: 0; }
        .p-0 { padding: 0; }
        
        .hidden { display: none; }
        .visible { display: block; }
        
        /* ===== CUSTOM UNIT STYLES ===== */
        
        .selected-items {
            margin-top: var(--space-lg);
        }
        
        .badge {
            display: inline-block;
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-medium);
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--radius-full);
            white-space: nowrap;
        }
        
        hr {
            border: none;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--border-color), transparent);
        }
        
        /* Enhanced form styling for custom units */
        .form-group small {
            display: block;
            margin-top: var(--space-xs);
            font-size: var(--font-size-xs);
            color: var(--text-muted);
        }
        
        /* ===== WORKFLOW SYSTEM ===== */
        
        .workflow-container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        .workflow-step {
            display: none;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        .workflow-step.active {
            display: block;
        }
        
        .step-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 2rem;
            height: 2rem;
            background: var(--primary-gold);
            color: var(--primary-bg);
            border-radius: 50%;
            font-weight: var(--font-weight-bold);
            margin-right: var(--space-md);
        }
        
        .workflow-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: var(--space-2xl);
            padding-top: var(--space-xl);
            border-top: 1px solid var(--border-color);
        }
        
        /* ===== IMPORT SECTIONS ===== */
        
        .import-section {
            padding: var(--space-lg);
            border: 2px dashed var(--border-color);
            border-radius: var(--radius-lg);
            text-align: center;
            transition: all var(--transition-normal);
        }
        
        .import-section:hover {
            border-color: var(--primary-gold);
            background: rgba(212, 175, 55, 0.05);
        }
        
        .import-section.loaded {
            border-color: var(--success-color);
            background: rgba(39, 174, 96, 0.1);
        }
        
        .roster-info {
            margin-top: var(--space-lg);
            padding: var(--space-md);
            background: var(--accent-bg);
            border-radius: var(--radius-md);
            text-align: left;
        }
        
        .roster-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: var(--space-md);
            margin-top: var(--space-md);
        }
        
        .stat-card {
            background: var(--secondary-bg);
            padding: var(--space-md);
            border-radius: var(--radius-md);
            text-align: center;
        }
        
        .stat-value {
            font-size: var(--font-size-2xl);
            font-weight: var(--font-weight-bold);
            color: var(--primary-gold);
        }
        
        .stat-label {
            font-size: var(--font-size-xs);
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* ===== KEYWORD MANAGEMENT ===== */
        
        .keyword-management {
            display: grid;
            gap: var(--space-xl);
        }
        
        .keyword-header {
            margin-bottom: var(--space-lg);
        }
        
        .keyword-description {
            color: var(--text-secondary);
            margin-bottom: var(--space-md);
            line-height: 1.6;
        }
        
        .keyword-search {
            position: relative;
            max-width: 400px;
            margin: 0 auto var(--space-lg);
        }
        
        .keyword-search .search-icon {
            position: absolute;
            right: var(--space-md);
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }
        
        .keyword-section {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            margin-bottom: var(--space-lg);
        }
        
        .keyword-section h4 {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-md);
            color: var(--primary-gold);
            font-weight: var(--font-weight-semibold);
        }
        
        .keyword-help {
            color: var(--text-secondary);
            font-size: var(--font-size-sm);
            margin-bottom: var(--space-md);
            line-height: 1.5;
        }
        
        .custom-keyword-input {
            display: flex;
            gap: var(--space-md);
            margin-bottom: var(--space-md);
        }
        
        .custom-keyword-input .form-input {
            flex: 1;
        }
        
        .keyword-examples {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-sm);
            align-items: center;
        }
        
        .keyword-examples strong {
            color: var(--text-primary);
            margin-right: var(--space-sm);
        }
        
        .keyword-example {
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--space-xs) var(--space-sm);
            color: var(--text-primary);
            font-family: var(--font-family-mono);
            font-size: var(--font-size-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }
        
        .keyword-example:hover {
            background: var(--primary-gold);
            color: var(--primary-bg);
            border-color: var(--primary-gold);
            transform: translateY(-1px);
        }
        
        .assignment-controls {
            display: flex;
            gap: var(--space-md);
            margin-bottom: var(--space-lg);
            flex-wrap: wrap;
        }
        
        .assignment-controls select,
        .assignment-controls .form-input {
            flex: 1;
            min-width: 200px;
        }
        
        .keyword-assignments {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            background: var(--secondary-bg);
        }
        
        .assignment-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-md);
            border-bottom: 1px solid var(--border-color);
        }
        
        .assignment-item:last-child {
            border-bottom: none;
        }
        
        .assignment-info {
            flex: 1;
        }
        
        .assignment-target {
            font-weight: var(--font-weight-medium);
            color: var(--text-primary);
            margin-bottom: var(--space-xs);
        }
        
        .assignment-keyword {
            font-family: var(--font-family-mono);
            font-size: var(--font-size-sm);
            color: var(--primary-gold);
            background: var(--primary-bg);
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--radius-sm);
            display: inline-block;
        }
        
        .remove-assignment {
            background: var(--error-color);
            color: white;
            border: none;
            border-radius: var(--radius-sm);
            padding: var(--space-xs);
            cursor: pointer;
            transition: all var(--transition-fast);
        }
        
        .remove-assignment:hover {
            background: var(--error-dark);
            transform: scale(1.1);
        }
        
        .keyword-filters {
            background: var(--secondary-bg);
            padding: var(--space-xl);
            border-radius: var(--radius-lg);
        }
        
        .keyword-list {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-sm);
            margin-top: var(--space-md);
        }
        
        .keyword-tag {
            display: inline-flex;
            align-items: center;
            gap: var(--space-xs);
            padding: var(--space-xs) var(--space-md);
            background: var(--accent-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-full);
            font-size: var(--font-size-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }
        
        .keyword-tag:hover {
            background: var(--panel-bg);
            border-color: var(--primary-gold);
        }
        
        .keyword-tag.active {
            background: var(--primary-gold);
            color: var(--primary-bg);
            border-color: var(--primary-gold);
        }
        
        .keyword-tag .remove {
            cursor: pointer;
            font-size: 1rem;
            opacity: 0.7;
        }
        
        .keyword-tag .remove:hover {
            opacity: 1;
        }
        
        .keyword-editor {
            margin-top: var(--space-lg);
            padding-top: var(--space-lg);
            border-top: 1px solid var(--border-color);
        }
        
        .keyword-editor .form-group {
            display: flex;
            gap: var(--space-md);
        }
        
        /* ===== UNIT SELECTION ===== */
        
        .selection-panel {
            background: var(--secondary-bg);
            padding: var(--space-xl);
            border-radius: var(--radius-lg);
            height: 600px;
            display: flex;
            flex-direction: column;
        }
        
        .unit-filter {
            margin-bottom: var(--space-lg);
        }
        
        .unit-list {
            flex: 1;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--space-md);
        }
        
        .unit-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: var(--space-lg);
            margin-bottom: var(--space-lg);
            background: var(--panel-bg);
            border: 2px solid var(--border-color);
            border-radius: var(--radius-lg);
            cursor: pointer;
            transition: all var(--transition-fast);
            position: relative;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .unit-item:last-child {
            margin-bottom: 0;
        }
        
        .unit-item:hover {
            border-color: var(--primary-gold);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.3);
        }
        
        .unit-item.selected {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.15), rgba(255, 215, 0, 0.1));
            border-color: var(--primary-gold);
            border-width: 3px;
            box-shadow: 0 4px 16px rgba(212, 175, 55, 0.4);
        }
        
        .unit-item.selected::before {
            content: '';
            position: absolute;
            top: var(--space-md);
            right: var(--space-md);
            width: 28px;
            height: 28px;
            background: var(--primary-gold);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .unit-item.selected::after {
            content: '✓';
            position: absolute;
            top: var(--space-md);
            right: var(--space-md);
            width: 28px;
            height: 28px;
            color: var(--primary-bg);
            font-weight: bold;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
        }
        
        .unit-info {
            flex: 1;
            padding-right: var(--space-lg);
        }
        
        .unit-name {
            font-weight: var(--font-weight-semibold);
            color: var(--text-primary);
            font-size: var(--font-size-lg);
            margin-bottom: var(--space-sm);
        }
        
        .unit-stats {
            font-size: var(--font-size-sm);
            color: var(--text-secondary);
            margin-bottom: var(--space-md);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
            gap: var(--space-sm);
            background: var(--secondary-bg);
            padding: var(--space-md);
            border-radius: var(--radius-md);
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-label {
            font-size: var(--font-size-xs);
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: var(--space-xs);
        }
        
        .stat-value {
            font-weight: var(--font-weight-bold);
            color: var(--text-primary);
            font-size: var(--font-size-md);
        }
        
        .unit-weapons {
            margin-top: var(--space-md);
        }
        
        .weapon-count {
            font-size: var(--font-size-sm);
            color: var(--text-secondary);
            margin-bottom: var(--space-sm);
        }
        
        .weapon-list {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-xs);
        }
        
        .weapon-tag {
            background: var(--accent-bg);
            color: var(--text-primary);
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--radius-sm);
            font-size: var(--font-size-xs);
            border: 1px solid var(--border-color);
        }
        
        .unit-keywords {
            margin-top: var(--space-md);
        }
        
        .keyword-count {
            font-size: var(--font-size-sm);
            color: var(--text-secondary);
            margin-bottom: var(--space-sm);
        }
        
        .selection-summary {
            background: var(--accent-bg);
            border: 2px solid var(--primary-gold);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            margin-bottom: var(--space-lg);
            text-align: center;
        }
        
        .selection-count {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }
        
        .count-item {
            text-align: center;
        }
        
        .count-number {
            font-size: var(--font-size-xl);
            font-weight: var(--font-weight-bold);
            color: var(--primary-gold);
            display: block;
        }
        
        .count-label {
            font-size: var(--font-size-sm);
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .selection-actions {
            display: flex;
            gap: var(--space-md);
            margin-top: var(--space-lg);
        }
        
        .select-all-btn,
        .clear-selection-btn {
            flex: 1;
            padding: var(--space-md);
            border-radius: var(--radius-lg);
            font-weight: var(--font-weight-medium);
            cursor: pointer;
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
            font-size: var(--font-size-md);
        }
        
        .select-all-btn {
            background: var(--primary-gold);
            color: var(--primary-bg);
            border: 2px solid var(--primary-gold);
        }
        
        .select-all-btn:hover {
            background: var(--secondary-gold);
            border-color: var(--secondary-gold);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.4);
        }
        
        .clear-selection-btn {
            background: transparent;
            color: var(--text-primary);
            border: 2px solid var(--border-color);
        }
        
        .clear-selection-btn:hover {
            background: var(--error-color);
            color: white;
            border-color: var(--error-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
        }
        
        .unit-keywords {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-xs);
            margin-top: var(--space-xs);
        }
        
        .unit-keyword {
            padding: 2px 6px;
            background: var(--accent-bg);
            border-radius: var(--radius-sm);
            font-size: 10px;
            color: var(--text-muted);
        }
        
        .selected-units {
            margin-top: var(--space-lg);
            padding-top: var(--space-lg);
            border-top: 1px solid var(--border-color);
            max-height: 200px;
            overflow-y: auto;
        }
        
        /* ===== SIMULATION CONFIG ===== */
        
        .simulation-config {
            display: grid;
            gap: var(--space-xl);
        }
        
        .config-section {
            background: var(--secondary-bg);
            padding: var(--space-xl);
            border-radius: var(--radius-lg);
        }
        
        .battle-preview {
            background: var(--accent-bg);
            padding: var(--space-lg);
            border-radius: var(--radius-md);
            border-left: 4px solid var(--primary-gold);
        }
        
        .battle-summary {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: var(--space-lg);
            align-items: center;
        }
        
        .army-summary {
            text-align: center;
        }
        
        .vs-indicator {
            font-size: var(--font-size-2xl);
            font-weight: var(--font-weight-bold);
            color: var(--primary-gold);
        }
        
        /* ===== RESULTS DASHBOARD ===== */
        
        .results-dashboard {
            display: grid;
            gap: var(--space-lg);
        }
        
        .results-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--space-lg);
            margin-bottom: var(--space-xl);
        }
        
        .result-card {
            background: var(--secondary-bg);
            padding: var(--space-lg);
            border-radius: var(--radius-lg);
            text-align: center;
            border: 1px solid var(--border-color);
        }
        
        .result-value {
            font-size: var(--font-size-3xl);
            font-weight: var(--font-weight-bold);
            color: var(--primary-gold);
            margin-bottom: var(--space-sm);
        }
        
        .result-label {
            color: var(--text-secondary);
            text-transform: uppercase;
            font-size: var(--font-size-sm);
            letter-spacing: 0.5px;
        }
        
        .chart-container {
            background: var(--secondary-bg);
            padding: var(--space-xl);
            border-radius: var(--radius-lg);
            margin-bottom: var(--space-lg);
        }
        
        .chart-title {
            margin-bottom: var(--space-lg);
            color: var(--text-primary);
            font-weight: var(--font-weight-medium);
        }
        
        /* ===== ANIMATIONS ===== */
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        /* ===== RESPONSIVE DESIGN ===== */
        
        @media (max-width: 768px) {
            .workflow-actions {
                flex-direction: column;
                gap: var(--space-md);
            }
            
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .selection-panel {
                height: auto;
                max-height: 400px;
            }
            
            .battle-summary {
                grid-template-columns: 1fr;
                text-align: center;
            }
            
            .results-summary {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
        }
        
        /* ===== RESULTS DASHBOARD & ANALYTICS ===== */
        
        .results-header {
            margin-bottom: 2rem;
        }
        
        .results-title h3 {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            color: var(--primary-color);
        }
        
        .results-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            opacity: 0.8;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.9rem;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 3rem;
        }
        
        .result-card {
            background: linear-gradient(135deg, var(--card-bg) 0%, rgba(255, 255, 255, 0.05) 100%);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .result-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }
        
        .result-card.primary {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--accent-color) 100%);
            color: white;
        }
        
        .card-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .card-header h4 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
        }
        
        .primary-metric {
            font-size: 2.5rem;
            font-weight: 700;
            line-height: 1;
            margin-bottom: 0.5rem;
        }
        
        .metric-subtitle {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 0.25rem;
        }
        
        .metric-detail {
            font-size: 0.85rem;
            opacity: 0.7;
        }
        
        .combo-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .combo-weapon, .combo-target {
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .combo-arrow {
            opacity: 0.6;
        }
        
        .battlefield-overview {
            margin-bottom: 3rem;
            padding: 1.5rem;
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }
        
        .battlefield-overview h4 {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            color: var(--primary-color);
        }
        
        .battlefield-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
        }
        
        .battlefield-section h5 {
            margin-bottom: 1rem;
            color: var(--text-color);
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 0.5rem;
        }
        
        .force-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .force-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid var(--accent-color);
        }
        
        .force-item.weapon {
            border-left-color: var(--error-color);
        }
        
        .force-item.defender {
            border-left-color: var(--success-color);
        }
        
        .force-stats {
            font-size: 0.85rem;
            font-family: 'Courier New', monospace;
            opacity: 0.8;
            margin-left: auto;
        }
        
        .analytics-section {
            margin-bottom: 3rem;
            padding: 2rem;
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }
        
        .analytics-section h4 {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            color: var(--primary-color);
        }
        
        .weapon-analysis, .defender-analysis {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .analysis-row {
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .analysis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        
        .analysis-name {
            font-weight: 600;
            font-size: 1.1rem;
        }
        
        .analysis-score {
            font-weight: 700;
            color: var(--accent-color);
        }
        
        .analysis-score.mortality {
            color: var(--error-color);
        }
        
        .analysis-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .detail-item {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
        }
        
        .detail-label {
            opacity: 0.8;
        }
        
        .detail-value {
            font-weight: 600;
        }
        
        .progress-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-color), var(--primary-color));
            transition: width 0.3s ease;
        }
        
        .progress-bar.survival .progress-fill {
            background: linear-gradient(90deg, var(--success-color), var(--primary-color));
        }
        
        .combat-matrix-container {
            overflow-x: auto;
        }
        
        .combat-matrix {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }
        
        .combat-matrix th,
        .combat-matrix td {
            padding: 0.75rem;
            text-align: center;
            border: 1px solid var(--border-color);
        }
        
        .matrix-corner {
            background: var(--primary-color);
            color: white;
            font-weight: 600;
        }
        
        .weapon-header,
        .defender-header {
            background: rgba(255, 255, 255, 0.1);
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .matrix-cell {
            position: relative;
            min-width: 80px;
            font-size: 0.8rem;
        }
        
        .matrix-cell.empty {
            opacity: 0.3;
        }
        
        .cell-damage {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }
        
        .cell-kills {
            font-size: 0.7rem;
            opacity: 0.8;
        }
        
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }
        
        .chart-container {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
        }
        
        .chart-container.full-width {
            grid-column: 1 / -1;
        }
        
        .chart-container h4 {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            color: var(--primary-color);
        }
        
        .bar-chart {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .bar-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .bar-label {
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .bar-container {
            position: relative;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-color), var(--primary-color));
            transition: width 0.5s ease;
        }
        
        .bar-value {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.85rem;
            font-weight: 600;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .pie-chart-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        
        .pie-chart {
            position: relative;
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: conic-gradient(from 0deg, var(--accent-color) 0deg, var(--primary-color) 360deg);
        }
        
        .pie-legend {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
        
        .survival-chart {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .survival-item {
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        
        .survival-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .survival-name {
            font-weight: 600;
        }
        
        .survival-rate {
            font-weight: 700;
            color: var(--success-color);
        }
        
        .survival-bar {
            position: relative;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }
        
        .survival-fill {
            position: absolute;
            left: 0;
            height: 100%;
            background: var(--success-color);
            transition: width 0.5s ease;
        }
        
        .mortality-fill {
            position: absolute;
            right: 0;
            height: 100%;
            background: var(--error-color);
            transition: width 0.5s ease;
        }
        
        .survival-details {
            opacity: 0.8;
        }
        
        .timeline-chart {
            position: relative;
            height: 200px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 1rem;
        }
        
        .timeline-axis {
            position: relative;
            height: 100%;
            border-bottom: 2px solid var(--border-color);
        }
        
        .timeline-point {
            position: absolute;
            bottom: 0;
            width: 4px;
            background: var(--accent-color);
            border-radius: 2px 2px 0 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .timeline-point:hover {
            background: var(--primary-color);
            width: 6px;
        }
        
        .timeline-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }
        
        .timeline-point:hover .timeline-tooltip {
            opacity: 1;
        }
        
        .timeline-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.8rem;
            opacity: 0.8;
        }
        
        .export-section {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 2rem;
        }
        
        .export-section h4 {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            color: var(--primary-color);
        }
        
        .export-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .export-option {
            text-align: center;
        }
        
        .export-option .btn {
            width: 100%;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 1rem;
        }
        
        .export-description {
            font-size: 0.85rem;
            opacity: 0.8;
            margin: 0;
        }
        
        .export-summary {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }
        
        .summary-stat {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            max-width: 400px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            animation: slideIn 0.3s ease;
        }
        
        .success-toast {
            background: var(--success-color);
            color: white;
        }
        
        .toast-content {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem;
        }
        
        .toast-close {
            background: none;
            border: none;
            color: inherit;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            margin-left: auto;
        }
        
        .toast-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* ===== WEAPON SELECTION MODAL ===== */
        
        .weapon-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: var(--card-bg);
            border-radius: var(--radius-lg);
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-lg);
            border-bottom: 1px solid var(--border-color);
            background: linear-gradient(135deg, var(--primary-gold), var(--secondary-gold));
            color: var(--primary-bg);
        }
        
        .modal-header h4 {
            margin: 0;
            font-size: var(--font-size-lg);
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--primary-bg);
            font-size: 24px;
            cursor: pointer;
            padding: var(--space-xs);
            border-radius: var(--radius-sm);
            transition: background var(--transition-fast);
        }
        
        .modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .modal-body {
            padding: var(--space-lg);
            max-height: 60vh;
            overflow-y: auto;
        }
        
        .weapon-selection-list {
            display: grid;
            gap: var(--space-md);
        }
        
        .weapon-option {
            display: flex;
            align-items: center;
            padding: var(--space-md);
            border: 2px solid var(--border-color);
            border-radius: var(--radius-lg);
            cursor: pointer;
            transition: all var(--transition-fast);
            background: var(--secondary-bg);
        }
        
        .weapon-option:hover {
            border-color: var(--primary-gold);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.3);
        }
        
        .weapon-option.selected {
            border-color: var(--primary-gold);
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.15), rgba(255, 215, 0, 0.1));
        }
        
        .weapon-checkbox {
            margin-right: var(--space-md);
            transform: scale(1.2);
            accent-color: var(--primary-gold);
        }
        
        .weapon-info {
            flex: 1;
        }
        
        .weapon-name {
            font-weight: var(--font-weight-semibold);
            color: var(--text-primary);
            margin-bottom: var(--space-xs);
        }
        
        .weapon-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: var(--space-sm);
            margin-top: var(--space-sm);
        }
        
        .weapon-stat {
            text-align: center;
            font-size: var(--font-size-sm);
        }
        
        .weapon-stat-label {
            color: var(--text-secondary);
            font-size: var(--font-size-xs);
            text-transform: uppercase;
        }
        
        .weapon-stat-value {
            color: var(--text-primary);
            font-weight: var(--font-weight-bold);
        }
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: var(--space-md);
            padding: var(--space-lg);
            border-top: 1px solid var(--border-color);
            background: var(--secondary-bg);
        }
        
        /* ===== NOTIFICATION SYSTEM ===== */
        
        .notification-container {
            position: fixed;
            top: var(--space-lg);
            right: var(--space-lg);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            max-width: 400px;
        }
        
        .notification {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: flex-start;
            gap: var(--space-md);
            animation: slideInRight 0.3s ease;
        }
        
        .notification-success {
            border-left: 4px solid var(--success-color);
        }
        
        .notification-warning {
            border-left: 4px solid var(--warning-color);
        }
        
        .notification-error {
            border-left: 4px solid var(--error-color);
        }
        
        .notification-info {
            border-left: 4px solid var(--primary-gold);
        }
        
        .notification-content {
            display: flex;
            align-items: flex-start;
            gap: var(--space-sm);
            flex: 1;
        }
        
        .notification-icon {
            color: var(--primary-gold);
            font-size: 20px;
            margin-top: 2px;
        }
        
        .notification-success .notification-icon {
            color: var(--success-color);
        }
        
        .notification-warning .notification-icon {
            color: var(--warning-color);
        }
        
        .notification-error .notification-icon {
            color: var(--error-color);
        }
        
        .notification-message {
            color: var(--text-primary);
            line-height: 1.5;
        }
        
        .notification-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: var(--space-xs);
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
        }
        
        .notification-close:hover {
            background: var(--secondary-bg);
            color: var(--text-primary);
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <!-- Skip Links für bessere Zugänglichkeit -->
    <a href="#main-content" class="skip-link">Zum Hauptinhalt springen</a>
    <a href="#simulation-controls" class="skip-link">Zu den Simulationseinstellungen springen</a>
    <a href="#results" class="skip-link">Zu den Ergebnissen springen</a>

    <div class="container">
        <!-- Hauptheader mit semantischer Struktur -->
        <header class="site-header" role="banner">
            <h1 class="site-title">Warhammer 40k Combat Simulator</h1>
            <p class="site-description">
                Präzise mathematische Simulation für Warhammer 40.000 Kampfszenarien
            </p>
            <span class="version-badge" aria-label="Version 2.1">v2.1</span>
        </header>

        <!-- Hauptinhalt mit verbesserter Semantik -->
        <main id="main-content" role="main" aria-labelledby="main-heading">
            <h2 id="main-heading" class="sr-only">Advanced Combat Simulator Interface</h2>
            
            <!-- Step-by-Step Workflow -->
            <div class="workflow-container">
                <!-- Step 1: Roster Import -->
                <section class="card workflow-step active" id="step-import" aria-labelledby="import-heading">
                    <header class="card-header">
                        <h2 id="import-heading" class="card-title">
                            <span class="step-number">1</span>
                            <i class="material-icons" aria-hidden="true">upload_file</i>
                            Import BattleScribe Rosters
                        </h2>
                    </header>
                    
                    <div class="card-body">
                        <div class="main-grid">
                            <!-- Angreifer-Import -->
                            <div class="import-section" id="attacker-import">
                                <h3><i class="material-icons" aria-hidden="true">gps_fixed</i> Angreifer-Roster</h3>
                                <div class="form-group">
                                    <label for="attacker-upload" class="form-label required">
                                        Angreifer BattleScribe-Datei
                                    </label>
                                    <input 
                                        type="file" 
                                        id="attacker-upload" 
                                        class="form-input"
                                        accept=".json,.ros"
                                        required
                                        aria-describedby="attacker-upload-help"
                                        onchange="loadAttackerRoster(event)"
                                    >
                                    <small id="attacker-upload-help" class="text-muted">
                                        Laden Sie Ihr Angreifer-Roster (.json/.ros)
                                    </small>
                                </div>
                                <div id="attacker-roster-info" class="roster-info" style="display: none;"></div>
                            </div>

                            <!-- Verteidiger-Import -->
                            <div class="import-section" id="defender-import">
                                <h3><i class="material-icons" aria-hidden="true">shield</i> Verteidiger-Roster</h3>
                                <div class="form-group">
                                    <label for="defender-upload" class="form-label required">
                                        Verteidiger BattleScribe-Datei
                                    </label>
                                    <input 
                                        type="file" 
                                        id="defender-upload" 
                                        class="form-input"
                                        accept=".json,.ros"
                                        required
                                        aria-describedby="defender-upload-help"
                                        onchange="loadDefenderRoster(event)"
                                    >
                                    <small id="defender-upload-help" class="text-muted">
                                        Laden Sie Ihr Verteidiger-Roster (.json/.ros)
                                    </small>
                                </div>
                                <div id="defender-roster-info" class="roster-info" style="display: none;"></div>
                            </div>
                        </div>

                        <div class="workflow-actions">
                            <div></div>
                            <button 
                                id="next-to-keywords" 
                                class="btn btn-primary btn-large"
                                onclick="goToStep('keywords')"
                                disabled
                            >
                                <i class="material-icons" aria-hidden="true">arrow_forward</i>
                                Weiter zu Keywords
                            </button>
                        </div>
                    </div>
                </section>

                <!-- Step 2: Keyword Management -->
                <section class="card workflow-step" id="step-keywords" aria-labelledby="keywords-heading">
                    <header class="card-header">
                        <h2 id="keywords-heading" class="card-title">
                            <span class="step-number">2</span>
                            <i class="material-icons" aria-hidden="true">label</i>
                            Keyword Management
                        </h2>
                    </header>
                    
                    <div class="card-body">
                        <div class="keyword-management">
                            <div class="keyword-filters">
                                <div class="keyword-header">
                                    <h3>Keyword-Verwaltung</h3>
                                    <p class="keyword-description">
                                        Verwalten Sie Keywords für bessere Filterung und Kategorisierung. 
                                        Verwenden Sie Custom Keywords wie RH1, RW1, etc. für spezielle Modifikationen.
                                    </p>
                                    <div class="keyword-search">
                                        <input 
                                            type="text" 
                                            id="keyword-search" 
                                            class="form-input"
                                            placeholder="Keywords durchsuchen..."
                                            onkeyup="searchKeywords()"
                                        >
                                        <i class="material-icons search-icon" aria-hidden="true">search</i>
                                    </div>
                                </div>
                                
                                <div class="keyword-section">
                                    <h4><i class="material-icons" aria-hidden="true">auto_awesome</i> Extrahierte Keywords</h4>
                                    <div id="available-keywords" class="keyword-list"></div>
                                </div>
                                
                                <div class="keyword-section">
                                    <h4><i class="material-icons" aria-hidden="true">edit</i> Custom Keywords hinzufügen</h4>
                                    <p class="keyword-help">
                                        Fügen Sie spezielle Keywords hinzu (z.B. RH1 für +1 Trefferbonus, RW1 für +1 Verwundungsbonus)
                                    </p>
                                    <div class="custom-keyword-input">
                                        <input 
                                            type="text" 
                                            id="custom-keyword" 
                                            class="form-input"
                                            placeholder="z.B. RH1, RW1, COVER_IGNORE..."
                                            onkeydown="handleKeywordEnter(event)"
                                            maxlength="50"
                                        >
                                        <button 
                                            class="btn btn-primary btn-small"
                                            onclick="addCustomKeyword()"
                                            title="Keyword hinzufügen"
                                        >
                                            <i class="material-icons" aria-hidden="true">add</i>
                                            Hinzufügen
                                        </button>
                                    </div>
                                    <div class="keyword-examples">
                                        <strong>Beispiele:</strong>
                                        <button class="keyword-example" onclick="addPredefinedKeyword('RH1')">RH1</button>
                                        <button class="keyword-example" onclick="addPredefinedKeyword('RW1')">RW1</button>
                                        <button class="keyword-example" onclick="addPredefinedKeyword('RS1')">RS1</button>
                                        <button class="keyword-example" onclick="addPredefinedKeyword('RAP1')">RAP1</button>
                                        <button class="keyword-example" onclick="addPredefinedKeyword('RD1')">RD1</button>
                                    </div>
                                </div>
                                
                                <div class="keyword-editor">
                                    <h4>Eigene Keywords hinzufügen</h4>
                                    <div class="form-group">
                                        <input 
                                            type="text" 
                                            id="custom-keyword" 
                                            class="form-input"
                                            placeholder="Neues Keyword eingeben..."
                                            onkeypress="handleKeywordEnter(event)"
                                        >
                                        <button class="btn btn-secondary" onclick="addCustomKeyword()">
                                            <i class="material-icons" aria-hidden="true">add</i>
                                            Hinzufügen
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                                <div class="keyword-assignment-section">
                                    <h4><i class="material-icons" aria-hidden="true">link</i> Keywords zu Einheiten/Waffen zuweisen</h4>
                                    <p class="keyword-help">
                                        Weisen Sie Custom Keywords zu bestimmten Einheiten oder Waffen zu für spezielle Modifikationen.
                                    </p>
                                    
                                    <div class="assignment-controls">
                                        <select id="assignment-target" class="form-select">
                                            <option value="">Ziel auswählen...</option>
                                        </select>
                                        <select id="assignment-keyword" class="form-select">
                                            <option value="">Keyword auswählen...</option>
                                        </select>
                                        <button 
                                            class="btn btn-secondary btn-small"
                                            onclick="assignKeyword()"
                                            title="Keyword zuweisen"
                                        >
                                            <i class="material-icons" aria-hidden="true">link</i>
                                            Zuweisen
                                        </button>
                                    </div>
                                    
                                    <div class="keyword-assignments" id="keyword-assignments">
                                        <!-- Zugewiesene Keywords werden hier angezeigt -->
                                    </div>
                                </div>
                                
                                <div class="keyword-section">
                                    <h4><i class="material-icons" aria-hidden="true">list</i> Alle Keywords</h4>
                                    <div id="all-keywords" class="keyword-list"></div>
                                </div>

                        <div class="workflow-actions">
                            <button 
                                class="btn btn-secondary"
                                onclick="goToStep('import')"
                            >
                                <i class="material-icons" aria-hidden="true">arrow_back</i>
                                Zurück
                            </button>
                            <button 
                                id="next-to-selection" 
                                class="btn btn-primary btn-large"
                                onclick="goToStep('selection')"
                            >
                                <i class="material-icons" aria-hidden="true">arrow_forward</i>
                                Zur Auswahl
                            </button>
                        </div>
                    </div>
                </section>

                <!-- Step 3: Unit Selection -->
                <section class="card workflow-step" id="step-selection" aria-labelledby="selection-heading">
                    <header class="card-header">
                        <h2 id="selection-heading" class="card-title">
                            <span class="step-number">3</span>
                            <i class="material-icons" aria-hidden="true">checklist</i>
                            Select Units for Combat
                        </h2>
                    </header>
                    
                    <div class="card-body">
                        <div class="main-grid">
                            <!-- Attacker Selection -->
                            <div class="selection-panel">
                                <h3><i class="material-icons" aria-hidden="true">gps_fixed</i> Select Attackers</h3>
                                
                                <div id="attacker-selection-summary" class="selection-summary">
                                    <div class="selection-count">
                                        <div class="count-item">
                                            <span class="count-number">0</span>
                                            <span class="count-label">Selected</span>
                                        </div>
                                        <div class="count-item">
                                            <span class="count-number">0</span>
                                            <span class="count-label">Available</span>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="unit-filter">
                                    <input 
                                        type="text" 
                                        id="attacker-search" 
                                        class="form-input"
                                        placeholder="Search attackers..."
                                        onkeyup="filterUnits('attacker')"
                                    >
                                </div>
                                <div id="attacker-units" class="unit-list"></div>
                                
                                <!-- Weapon Selection Modal -->
                                <div id="weapon-selection-modal" class="weapon-modal" style="display: none;">
                                    <div class="modal-content">
                                        <div class="modal-header">
                                            <h4>Select Weapons for <span id="selected-unit-name"></span></h4>
                                            <button class="modal-close" onclick="closeWeaponModal()">&times;</button>
                                        </div>
                                        <div class="modal-body">
                                            <div id="weapon-list" class="weapon-selection-list"></div>
                                        </div>
                                        <div class="modal-footer">
                                            <button class="btn btn-secondary" onclick="closeWeaponModal()">Cancel</button>
                                            <button class="btn btn-primary" onclick="confirmWeaponSelection()">Confirm Selection</button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Defender Selection -->
                            <div class="selection-panel">
                                <h3><i class="material-icons" aria-hidden="true">shield</i> Select Defenders</h3>
                                
                                <div id="defender-selection-summary" class="selection-summary">
                                    <div class="selection-count">
                                        <div class="count-item">
                                            <span class="count-number">0</span>
                                            <span class="count-label">Selected</span>
                                        </div>
                                        <div class="count-item">
                                            <span class="count-number">0</span>
                                            <span class="count-label">Available</span>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="unit-filter">
                                    <input 
                                        type="text" 
                                        id="defender-search" 
                                        class="form-input"
                                        placeholder="Search defenders..."
                                        onkeyup="filterUnits('defender')"
                                    >
                                </div>
                                <div id="defender-units" class="unit-list"></div>
                            </div>
                        </div>

                        <div class="workflow-actions">
                            <button 
                                class="btn btn-secondary"
                                onclick="goToStep('keywords')"
                            >
                                <i class="material-icons" aria-hidden="true">arrow_back</i>
                                Zurück
                            </button>
                            <button 
                                id="start-simulation" 
                                class="btn btn-primary btn-large"
                                onclick="goToStep('simulation')"
                                disabled
                            >
                                <i class="material-icons" aria-hidden="true">play_arrow</i>
                                Zur Simulation
                            </button>
                        </div>
                    </div>
                </section>

                <!-- Step 4: Simulation Configuration -->
                <section class="card workflow-step" id="step-simulation" aria-labelledby="simulation-heading">
                    <header class="card-header">
                        <h2 id="simulation-heading" class="card-title">
                            <span class="step-number">4</span>
                            <i class="material-icons" aria-hidden="true">analytics</i>
                            Configure Battle
                        </h2>
                    </header>
                    
                    <div class="card-body">
                        <div class="simulation-config">
                            <div class="config-section">
                                <h3>Simulationsparameter</h3>
                                <div class="grid grid-3">
                                    <div class="form-group">
                                        <label for="iterations" class="form-label">Iterationen</label>
                                        <input 
                                            type="number" 
                                            id="iterations" 
                                            class="form-input"
                                            value="100000"
                                            min="1000"
                                            max="1000000"
                                            step="1000"
                                        >
                                        <small class="text-muted">Mehr = genauer, aber langsamer</small>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">
                                            <input type="checkbox" id="detailed-analysis" checked style="margin-right: 8px;">
                                            Detaillierte Analyse
                                        </label>
                                        <small class="text-muted">Zusätzliche Statistiken</small>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">
                                            <input type="checkbox" id="auto-export" style="margin-right: 8px;">
                                            Auto-Export
                                        </label>
                                        <small class="text-muted">Automatischer PDF-Export</small>
                                    </div>
                                </div>
                            </div>

                            <div class="config-section">
                                <h3>Schlacht-Übersicht</h3>
                                <div id="battle-preview" class="battle-preview"></div>
                            </div>
                        </div>

                        <div class="workflow-actions">
                            <button 
                                class="btn btn-secondary"
                                onclick="goToStep('selection')"
                            >
                                <i class="material-icons" aria-hidden="true">arrow_back</i>
                                Zurück
                            </button>
                            <button 
                                id="run-simulation" 
                                class="btn btn-primary btn-large"
                                onclick="runAdvancedSimulation()"
                            >
                                <i class="material-icons" aria-hidden="true">rocket_launch</i>
                                Schlacht beginnen!
                            </button>
                        </div>
                    </div>
                </section>

                <!-- Step 5: Results & Analytics -->
                <section class="card workflow-step" id="step-results" aria-labelledby="results-heading">
                    <header class="card-header">
                        <h2 id="results-heading" class="card-title">
                            <span class="step-number">5</span>
                            <i class="material-icons" aria-hidden="true">assessment</i>
                            Battle Results & Analysis
                        </h2>
                    </header>
                    
                    <div class="card-body">
                        <div id="results-dashboard" class="results-dashboard">
                            <!-- Results Summary Section -->
                            <div id="results-summary" class="results-summary-section">
                                <!-- Summary content will be populated by JavaScript -->
                            </div>
                            
                            <!-- Detailed Analytics Section -->
                            <div id="detailed-analytics" class="detailed-analytics-section">
                                <!-- Analytics content will be populated by JavaScript -->
                            </div>
                            
                            <!-- Data Visualization Section -->
                            <div id="data-visualization" class="data-visualization-section">
                                <!-- Charts and graphs will be populated by JavaScript -->
                            </div>
                            
                            <!-- Export Options Section -->
                            <div id="export-options" class="export-options-section">
                                <!-- Export options will be populated by JavaScript -->
                            </div>
                        </div>

                        <div class="workflow-actions">
                            <button 
                                class="btn btn-secondary"
                                onclick="goToStep('simulation')"
                            >
                                <i class="material-icons" aria-hidden="true">arrow_back</i>
                                Simulation wiederholen
                            </button>
                            
                            <button 
                                class="btn btn-success"
                                onclick="exportResultsPDF()"
                                id="export-pdf-btn"
                            >
                                <i class="material-icons" aria-hidden="true">picture_as_pdf</i>
                                PDF-Bericht erstellen
                            </button>
                            
                            <button 
                                class="btn btn-primary"
                                onclick="goToStep('import')"
                            >
                                <i class="material-icons" aria-hidden="true">refresh</i>
                                Neue Simulation
                            </button>
                        </div>
                                <i class="material-icons" aria-hidden="true">replay</i>
                                Neue Simulation
                            </button>
                            <button 
                                class="btn btn-primary"
                                onclick="exportResults()"
                            >
                                <i class="material-icons" aria-hidden="true">download</i>
                                Ergebnisse exportieren
                            </button>
                        </div>
                    </div>
                </section>
            </div>
        </main>

        <!-- Help & Info Sektion -->
        <aside class="help-section" role="complementary" aria-labelledby="help-heading">
            <details class="card">
                <summary class="card-header" id="help-heading">
                    <h2 class="card-title">
                        <i class="material-icons" aria-hidden="true">help</i>
                        Hilfe & Anleitung
                    </h2>
                </summary>
                
                <div class="card-body">
                    <div class="grid grid-2">
                        <div>
                            <h3>Erste Schritte</h3>
                            <ol>
                                <li>Laden Sie eine Waffen-JSON-Datei hoch</li>
                                <li>Laden Sie eine Verteidiger-JSON-Datei hoch</li>
                                <li>Wählen Sie Waffen und Verteidiger aus</li>
                                <li>Starten Sie die Simulation</li>
                            </ol>
                        </div>
                        <div>
                            <h3>JSON-Format</h3>
                            <p>Die JSON-Dateien müssen Arrays mit Objekten enthalten, die die Warhammer 40k Statistiken definieren.</p>
                            <p>Beispiel-Dateien finden Sie in der Dokumentation.</p>
                        </div>
                    </div>
                </div>
            </details>
        </aside>
    </div>

    <!-- Loading Overlay -->
    <div 
        id="loading-overlay" 
        class="loading-overlay" 
        role="dialog" 
        aria-modal="true" 
        aria-labelledby="loading-title"
        style="display: none;"
    >
        <div class="loading-content">
            <div class="loading-spinner" aria-hidden="true"></div>
            <h2 id="loading-title">Simulation läuft...</h2>
            <p id="loading-progress" aria-live="polite">Wird geladen...</p>
        </div>
    </div>

    <!-- Error Toast -->
    <div 
        id="error-toast" 
        class="toast toast-error" 
        role="alert" 
        aria-live="assertive"
        style="display: none;"
    >
        <div class="toast-content">
            <i class="material-icons" aria-hidden="true">error</i>
            <span id="error-message"></span>
            <button 
                class="toast-close" 
                onclick="hideErrorToast()"
                aria-label="Fehlermeldung schließen"
            >
                <i class="material-icons" aria-hidden="true">close</i>
            </button>
        </div>
    </div>

    <!-- JavaScript for Enhanced Combat Simulator -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script>
        // Enhanced Combat Simulator JavaScript - Version 2.1
        console.log('Warhammer 40k Combat Simulator v2.1 geladen');
        
        // Global state management for new workflow
        let attackerRoster = null;
        let defenderRoster = null;
        let availableKeywords = new Set();
        let selectedAttackers = [];
        let selectedDefenders = [];
        let currentStep = 'import';
        let currentResults = null;
        
        // Legacy compatibility
        let weaponsData = [];
        let defendersData = [];

        // Initialize on DOM load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded successfully');
            initializeModernSimulator();
        });
        
        function initializeModernSimulator() {
            console.log('Modern simulator interface initialized');
            
            // Initialize required field validation
            initializeRequiredFields();
            
            // Set focus to first interactive element
            const firstInput = document.getElementById('weapon-upload');
            if (firstInput) {
                firstInput.focus();
            }
            
            announceToScreenReader('Warhammer 40k Combat Simulator v2.1 geladen');
        }

        // ===== WORKFLOW MANAGEMENT =====
        
        function goToStep(stepName) {
            // Hide all steps
            document.querySelectorAll('.workflow-step').forEach(step => {
                step.classList.remove('active');
            });
            
            // Show target step
            const targetStep = document.getElementById(`step-${stepName}`);
            if (targetStep) {
                targetStep.classList.add('active');
                currentStep = stepName;
                
                // Step-specific initialization
                switch(stepName) {
                    case 'keywords':
                        displayKeywords();
                        validateKeywordStep();
                        break;
                    case 'selection':
                        populateUnitSelection();
                        break;
                    case 'simulation':
                        prepareBattleSimulation();
                        break;
                    case 'results':
                        displaySimulationResults();
                        break;
                }
                
                // Update progress and validation
                validateCurrentStep();
                announceToScreenReader(`Schritt ${stepName} aktiviert`);
            }
        }
        
        function validateCurrentStep() {
            switch(currentStep) {
                case 'import':
                    const nextBtn = document.getElementById('next-to-keywords');
                    if (nextBtn) {
                        nextBtn.disabled = !(attackerRoster && defenderRoster);
                    }
                    break;
                case 'keywords':
                    validateKeywordStep();
                    break;
                case 'selection':
                    const simBtn = document.getElementById('start-simulation');
                    if (simBtn) {
                        const hasAttackers = selectedAttackers.length > 0;
                        const hasDefenders = selectedDefenders.length > 0;
                        simBtn.disabled = !(hasAttackers && hasDefenders);
                        
                        // Update button text based on selection state
                        const btnText = simBtn.querySelector('span') || simBtn.childNodes[2];
                        if (btnText) {
                            if (!hasAttackers && !hasDefenders) {
                                btnText.textContent = ' Einheiten auswählen';
                            } else if (!hasAttackers) {
                                btnText.textContent = ' Angreifer auswählen';
                            } else if (!hasDefenders) {
                                btnText.textContent = ' Verteidiger auswählen';
                            } else {
                                btnText.textContent = ' Zur Simulation';
                            }
                        }
                    }
                    break;
                case 'simulation':
                    validateSimulationSettings();
                    break;
            }
        }

        // ===== DUAL ROSTER LOADING =====
        
        async function loadAttackerRoster(event) {
            const file = event.target.files[0];
            if (!file) return;

            showLoadingOverlay('Lade Angreifer-Roster...');
            
            try {
                const text = await file.text();
                const jsonData = JSON.parse(text);
                
                // Validate BattleScribe format - be more flexible
                console.log('Attacker JSON structure:', Object.keys(jsonData));
                
                // Check for various BattleScribe formats
                const isValidBattleScribe = 
                    jsonData.roster ||  // Standard format
                    jsonData.catalogue ||  // Catalogue format
                    jsonData.gameSystemName ||  // Direct game system
                    (jsonData.forces && Array.isArray(jsonData.forces)) ||  // Forces array
                    (jsonData.selections && Array.isArray(jsonData.selections)) ||  // Selections array
                    jsonData.name;  // Basic name field
                
                if (!isValidBattleScribe) {
                    console.error('Invalid attacker file structure:', jsonData);
                    throw new Error('Dies ist keine gültige BattleScribe-Roster-Datei. Unterstützte Formate: .ros, .rosz (BattleScribe Roster)');
                }
                
                const parsedData = parseBattleScribeFile(jsonData);
                attackerRoster = {
                    ...parsedData,
                    fileName: file.name,
                    loadedAt: new Date().toISOString(),
                    role: 'attacker'
                };
                
                displayRosterInfo('attacker', attackerRoster);
                extractKeywords();
                validateCurrentStep();
                
                announceToScreenReader(`Angreifer-Roster ${attackerRoster.rosterName} erfolgreich geladen`);
                
            } catch (error) {
                console.error('Error loading attacker roster:', error);
                console.error('File name:', file.name);
                console.error('File size:', file.size, 'bytes');
                console.error('File type:', file.type);
                
                // Verbesserte Fehlermeldung
                let errorMessage = `Fehler beim Laden des Angreifer-Rosters: ${error.message}`;
                if (error.message.includes('JSON')) {
                    errorMessage += '\n\nTipp: Stellen Sie sicher, dass die Datei eine gültige JSON-Datei (.ros) aus BattleScribe ist.';
                }
                
                showErrorToast(errorMessage);
                attackerRoster = null;
                document.getElementById('attacker-roster-info').style.display = 'none';
            } finally {
                hideLoadingOverlay();
            }
        }
        
        async function loadDefenderRoster(event) {
            const file = event.target.files[0];
            if (!file) return;

            showLoadingOverlay('Lade Verteidiger-Roster...');
            
            try {
                const text = await file.text();
                const jsonData = JSON.parse(text);
                
                // Validate BattleScribe format - be more flexible
                console.log('Defender JSON structure:', Object.keys(jsonData));
                
                // Check for various BattleScribe formats
                const isValidBattleScribe = 
                    jsonData.roster ||  // Standard format
                    jsonData.catalogue ||  // Catalogue format
                    jsonData.gameSystemName ||  // Direct game system
                    (jsonData.forces && Array.isArray(jsonData.forces)) ||  // Forces array
                    (jsonData.selections && Array.isArray(jsonData.selections)) ||  // Selections array
                    jsonData.name;  // Basic name field
                
                if (!isValidBattleScribe) {
                    console.error('Invalid defender file structure:', jsonData);
                    throw new Error('Dies ist keine gültige BattleScribe-Roster-Datei. Unterstützte Formate: .ros, .rosz (BattleScribe Roster)');
                }
                
                const parsedData = parseBattleScribeFile(jsonData);
                defenderRoster = {
                    ...parsedData,
                    fileName: file.name,
                    loadedAt: new Date().toISOString(),
                    role: 'defender'
                };
                
                displayRosterInfo('defender', defenderRoster);
                extractKeywords();
                validateCurrentStep();
                
                announceToScreenReader(`Verteidiger-Roster ${defenderRoster.rosterName} erfolgreich geladen`);
                
            } catch (error) {
                console.error('Error loading defender roster:', error);
                console.error('File name:', file.name);
                console.error('File size:', file.size, 'bytes');
                console.error('File type:', file.type);
                
                // Verbesserte Fehlermeldung
                let errorMessage = `Fehler beim Laden des Verteidiger-Rosters: ${error.message}`;
                if (error.message.includes('JSON')) {
                    errorMessage += '\n\nTipp: Stellen Sie sicher, dass die Datei eine gültige JSON-Datei (.ros) aus BattleScribe ist.';
                }
                
                showErrorToast(errorMessage);
                defenderRoster = null;
                document.getElementById('defender-roster-info').style.display = 'none';
            } finally {
                hideLoadingOverlay();
            }
        }
        
        function displayRosterInfo(role, roster) {
            const infoElement = document.getElementById(`${role}-roster-info`);
            const importSection = document.getElementById(`${role}-import`);
            
            infoElement.innerHTML = `
                <div class="roster-preview">
                    <div class="roster-header">
                        <h4><i class="material-icons" aria-hidden="true">check_circle</i> ${roster.rosterName}</h4>
                        <span class="roster-points">${roster.points} Punkte</span>
                    </div>
                    <div class="roster-stats">
                        <div class="stat-item">
                            <i class="material-icons" aria-hidden="true">sports_martial_arts</i>
                            <span>${roster.weapons.length} Waffen</span>
                        </div>
                        <div class="stat-item">
                            <i class="material-icons" aria-hidden="true">groups</i>
                            <span>${roster.defenders.length} Einheiten</span>
                        </div>
                        <div class="stat-item">
                            <i class="material-icons" aria-hidden="true">schedule</i>
                            <span>${new Date(roster.loadedAt).toLocaleTimeString()}</span>
                        </div>
                    </div>
                </div>
            `;
            
            infoElement.style.display = 'block';
            importSection.classList.add('loaded');
        }
        
        function extractKeywords() {
            availableKeywords.clear();
            
            // Extract from attacker roster
            if (attackerRoster) {
                [...attackerRoster.weapons, ...attackerRoster.defenders].forEach(unit => {
                    if (unit.keywords) {
                        unit.keywords.split(',').forEach(keyword => {
                            availableKeywords.add(keyword.trim().toUpperCase());
                        });
                    }
                });
            }
            
            // Extract from defender roster
            if (defenderRoster) {
                [...defenderRoster.weapons, ...defenderRoster.defenders].forEach(unit => {
                    if (unit.keywords) {
                        unit.keywords.split(',').forEach(keyword => {
                            availableKeywords.add(keyword.trim().toUpperCase());
                        });
                    }
                });
            }
            
            console.log(`Extracted ${availableKeywords.size} unique keywords from both rosters`);
            
            // Update keyword display if we're on the keywords step
            if (currentStep === 'keywords') {
                displayAvailableKeywords();
            }
        }

        // ===== KEYWORD MANAGEMENT SYSTEM =====
        
        let customKeywords = new Set();
        let keywordAssignments = new Map(); // targetId -> Set of keywords
        
        function extractKeywords() {
            const keywords = new Set();
            
            // Extrahiere Keywords aus beiden Rosters
            [attackerRoster, defenderRoster].forEach(roster => {
                if (!roster) return;
                
                function extractFromUnit(unit) {
                    // Unit Keywords
                    if (unit.keywords) {
                        unit.keywords.forEach(keyword => keywords.add(keyword.trim()));
                    }
                    
                    // Weapon Keywords
                    if (unit.weapons) {
                        unit.weapons.forEach(weapon => {
                            if (weapon.keywords) {
                                weapon.keywords.forEach(keyword => keywords.add(keyword.trim()));
                            }
                        });
                    }
                    
                    // Wargear Keywords
                    if (unit.wargear) {
                        unit.wargear.forEach(gear => {
                            if (gear.keywords) {
                                gear.keywords.forEach(keyword => keywords.add(keyword.trim()));
                            }
                        });
                    }
                    
                    // Nested units (für komplexe Strukturen)
                    if (unit.units) {
                        unit.units.forEach(subUnit => extractFromUnit(subUnit));
                    }
                }
                
                if (roster.forces) {
                    roster.forces.forEach(force => {
                        if (force.selections) {
                            force.selections.forEach(selection => extractFromUnit(selection));
                        }
                    });
                }
            });
            
            // Update display if we're on the keywords step
            if (currentStep === 'keywords') {
                displayKeywords();
            }
            
            return Array.from(keywords).filter(k => k && k.length > 0).sort();
        }
        
        function displayKeywords() {
            const availableKeywords = document.getElementById('available-keywords');
            const allKeywords = document.getElementById('all-keywords');
            
            const extractedKeywords = extractKeywords();
            const allKeywordsList = [...new Set([...extractedKeywords, ...customKeywords])].sort();
            
            // Extrahierte Keywords anzeigen
            if (availableKeywords) {
                availableKeywords.innerHTML = extractedKeywords.length > 0 
                    ? extractedKeywords.map(keyword => 
                        `<span class="keyword-tag" data-keyword="${keyword}">${keyword}</span>`
                    ).join('')
                    : '<p class="no-keywords">Keine Keywords in den Rosters gefunden.</p>';
            }
            
            // Alle Keywords anzeigen (extrahiert + custom)
            if (allKeywords) {
                allKeywords.innerHTML = allKeywordsList.length > 0
                    ? allKeywordsList.map(keyword => {
                        const isCustom = customKeywords.has(keyword);
                        return `<span class="keyword-tag ${isCustom ? 'custom' : ''}" data-keyword="${keyword}">
                            ${keyword}
                            ${isCustom ? '<i class="material-icons remove" onclick="removeCustomKeyword(\'' + keyword + '\')" title="Entfernen">close</i>' : ''}
                        </span>`;
                    }).join('')
                    : '<p class="no-keywords">Keine Keywords verfügbar.</p>';
            }
            
            // Assignment-Dropdowns aktualisieren
            updateAssignmentTargets();
            updateAssignmentKeywords();
        }
        
        function addCustomKeyword() {
            const input = document.getElementById('custom-keyword');
            const keyword = input.value.trim().toUpperCase();
            
            if (!keyword) {
                showNotification('Bitte geben Sie ein Keyword ein.', 'warning');
                return;
            }
            
            if (keyword.length > 50) {
                showNotification('Keyword ist zu lang (max. 50 Zeichen).', 'error');
                return;
            }
            
            if (customKeywords.has(keyword)) {
                showNotification('Keyword bereits vorhanden.', 'warning');
                return;
            }
            
            customKeywords.add(keyword);
            input.value = '';
            displayKeywords();
            showNotification(`Keyword "${keyword}" hinzugefügt.`, 'success');
        }
        
        function addPredefinedKeyword(keyword) {
            if (customKeywords.has(keyword)) {
                showNotification(`Keyword "${keyword}" bereits vorhanden.`, 'warning');
                return;
            }
            
            customKeywords.add(keyword);
            displayKeywords();
            showNotification(`Keyword "${keyword}" hinzugefügt.`, 'success');
        }
        
        function removeCustomKeyword(keyword) {
            customKeywords.delete(keyword);
            
            // Auch aus Zuweisungen entfernen
            for (let [targetId, keywords] of keywordAssignments) {
                keywords.delete(keyword);
                if (keywords.size === 0) {
                    keywordAssignments.delete(targetId);
                }
            }
            
            displayKeywords();
            updateAssignmentsList();
            showNotification(`Keyword "${keyword}" entfernt.`, 'success');
        }
        
        function handleKeywordEnter(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                addCustomKeyword();
            }
        }
        
        function updateAssignmentTargets() {
            const targetSelect = document.getElementById('assignment-target');
            if (!targetSelect) return;
            
            const targets = [];
            
            // Sammle alle verfügbaren Einheiten und Waffen
            [attackerRoster, defenderRoster].forEach((roster, rosterIndex) => {
                if (!roster) return;
                
                const rosterName = rosterIndex === 0 ? 'Angreifer' : 'Verteidiger';
                
                function collectTargets(unit, path = '') {
                    const unitName = unit.name || 'Unbenannte Einheit';
                    const unitId = `${rosterIndex}-unit-${unit.id || Math.random()}`;
                    const fullPath = path ? `${path} > ${unitName}` : `${rosterName} > ${unitName}`;
                    
                    targets.push({
                        id: unitId,
                        name: fullPath,
                        type: 'unit',
                        data: unit
                    });
                    
                    // Waffen sammeln
                    if (unit.weapons) {
                        unit.weapons.forEach((weapon, weaponIndex) => {
                            const weaponName = weapon.name || 'Unbenannte Waffe';
                            const weaponId = `${unitId}-weapon-${weaponIndex}`;
                            targets.push({
                                id: weaponId,
                                name: `${fullPath} > ${weaponName}`,
                                type: 'weapon',
                                data: weapon
                            });
                        });
                    }
                    
                    // Verschachtelte Einheiten
                    if (unit.units) {
                        unit.units.forEach(subUnit => collectTargets(subUnit, fullPath));
                    }
                }
                
                if (roster.forces) {
                    roster.forces.forEach(force => {
                        if (force.selections) {
                            force.selections.forEach(selection => collectTargets(selection));
                        }
                    });
                }
            });
            
            targetSelect.innerHTML = '<option value="">Ziel auswählen...</option>' +
                targets.map(target => 
                    `<option value="${target.id}">${target.name} (${target.type === 'unit' ? 'Einheit' : 'Waffe'})</option>`
                ).join('');
        }
        
        function updateAssignmentKeywords() {
            const keywordSelect = document.getElementById('assignment-keyword');
            if (!keywordSelect) return;
            
            const allKeywordsList = [...new Set([...extractKeywords(), ...customKeywords])].sort();
            
            keywordSelect.innerHTML = '<option value="">Keyword auswählen...</option>' +
                allKeywordsList.map(keyword => 
                    `<option value="${keyword}">${keyword}</option>`
                ).join('');
        }
        
        function assignKeyword() {
            const targetSelect = document.getElementById('assignment-target');
            const keywordSelect = document.getElementById('assignment-keyword');
            
            const targetId = targetSelect.value;
            const keyword = keywordSelect.value;
            
            if (!targetId || !keyword) {
                showNotification('Bitte wählen Sie sowohl ein Ziel als auch ein Keyword aus.', 'warning');
                return;
            }
            
            if (!keywordAssignments.has(targetId)) {
                keywordAssignments.set(targetId, new Set());
            }
            
            const targetKeywords = keywordAssignments.get(targetId);
            if (targetKeywords.has(keyword)) {
                showNotification('Keyword bereits diesem Ziel zugewiesen.', 'warning');
                return;
            }
            
            targetKeywords.add(keyword);
            updateAssignmentsList();
            
            // Dropdowns zurücksetzen
            targetSelect.value = '';
            keywordSelect.value = '';
            
            const targetName = targetSelect.options[targetSelect.selectedIndex]?.text || 'Unbekanntes Ziel';
            showNotification(`Keyword "${keyword}" zu "${targetName}" zugewiesen.`, 'success');
        }
        
        function updateAssignmentsList() {
            const assignmentsList = document.getElementById('keyword-assignments');
            if (!assignmentsList) return;
            
            if (keywordAssignments.size === 0) {
                assignmentsList.innerHTML = '<div class="no-assignments">Keine Keyword-Zuweisungen vorhanden.</div>';
                return;
            }
            
            let html = '';
            for (let [targetId, keywords] of keywordAssignments) {
                const targetSelect = document.getElementById('assignment-target');
                const targetOption = Array.from(targetSelect.options).find(opt => opt.value === targetId);
                const targetName = targetOption ? targetOption.text : 'Unbekanntes Ziel';
                
                for (let keyword of keywords) {
                    html += `
                        <div class="assignment-item">
                            <div class="assignment-info">
                                <div class="assignment-target">${targetName}</div>
                                <div class="assignment-keyword">${keyword}</div>
                            </div>
                            <button class="remove-assignment" onclick="removeAssignment('${targetId}', '${keyword}')" title="Zuweisung entfernen">
                                <i class="material-icons">close</i>
                            </button>
                        </div>
                    `;
                }
            }
            
            assignmentsList.innerHTML = html;
        }
        
        function removeAssignment(targetId, keyword) {
            const targetKeywords = keywordAssignments.get(targetId);
            if (targetKeywords) {
                targetKeywords.delete(keyword);
                if (targetKeywords.size === 0) {
                    keywordAssignments.delete(targetId);
                }
            }
            
            updateAssignmentsList();
            showNotification(`Keyword-Zuweisung entfernt.`, 'success');
        }
        
        function searchKeywords() {
            const searchTerm = document.getElementById('keyword-search').value.toLowerCase();
            const keywordTags = document.querySelectorAll('.keyword-tag');
            
            keywordTags.forEach(tag => {
                const keyword = tag.dataset.keyword.toLowerCase();
                const matches = keyword.includes(searchTerm);
                tag.style.display = matches ? 'inline-flex' : 'none';
            });
        }
            if (!/^[A-Z0-9_\s]+$/.test(keyword)) {
                showErrorToast('Keywords dürfen nur Buchstaben, Zahlen, Unterstriche und Leerzeichen enthalten');
                input.focus();
                return;
            }
            
            availableKeywords.add(keyword);
            
            // Add to display
            const keywordContainer = document.getElementById('available-keywords');
            const keywordTag = createKeywordTag(keyword, true);
            keywordContainer.appendChild(keywordTag);
            
            // Clear input
            input.value = '';
            input.focus();
            
            announceToScreenReader(`Keyword ${keyword} hinzugefügt`);
        }
        
        function removeKeyword(keyword) {
            // Check if keyword is used in any loaded units
            const isUsedInAttacker = attackerRoster && 
                [...attackerRoster.weapons, ...attackerRoster.defenders].some(unit => 
                    unit.keywords && unit.keywords.toUpperCase().includes(keyword)
                );
                
            const isUsedInDefender = defenderRoster && 
                [...defenderRoster.weapons, ...defenderRoster.defenders].some(unit => 
                    unit.keywords && unit.keywords.toUpperCase().includes(keyword)
                );
            
            if (isUsedInAttacker || isUsedInDefender) {
                const confirmed = confirm(
                    `Das Keyword "${keyword}" wird in den geladenen Rosters verwendet. ` +
                    `Wenn Sie es entfernen, kann es die Filterung beeinträchtigen. ` +
                    `Möchten Sie es trotzdem entfernen?`
                );
                
                if (!confirmed) {
                    return;
                }
            }
            
            availableKeywords.delete(keyword);
            
            // Remove from display
            const keywordTag = document.querySelector(`[data-keyword="${keyword}"]`);
            if (keywordTag) {
                keywordTag.remove();
            }
            
            announceToScreenReader(`Keyword ${keyword} entfernt`);
        }
        
        function handleKeywordEnter(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                addCustomKeyword();
            }
        }
        
        function searchKeywords() {
            const searchTerm = document.getElementById('keyword-search').value.toLowerCase();
            const keywordTags = document.querySelectorAll('.keyword-tag');
            
            keywordTags.forEach(tag => {
                const keyword = tag.querySelector('.keyword-text').textContent.toLowerCase();
                const isVisible = keyword.includes(searchTerm);
                tag.style.display = isVisible ? 'flex' : 'none';
            });
            
            const visibleCount = Array.from(keywordTags).filter(tag => tag.style.display !== 'none').length;
            announceToScreenReader(`${visibleCount} Keywords gefunden`);
        }
        
        function validateKeywordStep() {
            // Keywords step is always valid - user can proceed with or without keywords
            const nextBtn = document.getElementById('next-to-selection');
            if (nextBtn) {
                nextBtn.disabled = false;
            }
            
            // Auto-populate unit selection data when keywords are ready
            if (attackerRoster && defenderRoster) {
                prepareUnitSelection();
            }
        }
        
        function prepareUnitSelection() {
            console.log('Preparing unit selection with available keywords:', Array.from(availableKeywords));
            
            // This will be called when transitioning to selection step
            if (currentStep === 'selection') {
                displayAttackerUnits();
                displayDefenderUnits();
                updateSelectedUnitsDisplay();
            }
        }

        // ===== ENHANCED UNIT SELECTION SYSTEM =====
        
        let selectedUnitForWeapons = null;
        let selectedWeapons = [];
        
        function populateUnitSelection() {
            const attackerUnits = document.getElementById('attacker-units');
            const defenderUnits = document.getElementById('defender-units');
            
            if (attackerUnits && attackerRoster) {
                attackerUnits.innerHTML = createUnitSelectionHTML(attackerRoster, 'attacker');
                updateSelectionSummary('attacker');
            }
            
            if (defenderUnits && defenderRoster) {
                defenderUnits.innerHTML = createUnitSelectionHTML(defenderRoster, 'defender');
                updateSelectionSummary('defender');
            }
            
            // Add selection event listeners
            document.querySelectorAll('.unit-item').forEach(item => {
                item.addEventListener('click', function() {
                    const role = this.dataset.role;
                    const unitIndex = this.dataset.unitIndex;
                    
                    if (role === 'attacker') {
                        selectUnitForWeapons(this, unitIndex, role);
                    } else {
                        toggleUnitSelection(this);
                    }
                });
            });
        }
        
        function selectUnitForWeapons(unitElement, unitIndex, role) {
            const roster = role === 'attacker' ? attackerRoster : defenderRoster;
            if (!roster || !roster.forces) return;
            
            // Find the unit
            let targetUnit = null;
            let currentIndex = 0;
            
            for (let force of roster.forces) {
                if (force.selections) {
                    for (let unit of force.selections) {
                        if (currentIndex == unitIndex) {
                            targetUnit = unit;
                            break;
                        }
                        currentIndex++;
                    }
                }
                if (targetUnit) break;
            }
            
            if (!targetUnit) return;
            
            selectedUnitForWeapons = {
                unit: targetUnit,
                element: unitElement,
                role: role,
                index: unitIndex
            };
            
            showWeaponSelectionModal(targetUnit);
        }
        
        function showWeaponSelectionModal(unit) {
            const modal = document.getElementById('weapon-selection-modal');
            const unitNameSpan = document.getElementById('selected-unit-name');
            const weaponList = document.getElementById('weapon-list');
            
            unitNameSpan.textContent = unit.name || 'Unnamed Unit';
            
            // Extract weapons from unit
            const weapons = extractUnitWeaponsDetailed(unit);
            
            weaponList.innerHTML = '';
            selectedWeapons = [];
            
            if (weapons.length === 0) {
                weaponList.innerHTML = '<p class="no-weapons">No weapons found for this unit.</p>';
            } else {
                weapons.forEach((weapon, index) => {
                    const weaponOption = createWeaponOption(weapon, index);
                    weaponList.appendChild(weaponOption);
                });
            }
            
            modal.style.display = 'flex';
        }
        
        function extractUnitWeaponsDetailed(unit) {
            const weapons = [];
            
            // Check selections for weapons
            if (unit.selections) {
                unit.selections.forEach(selection => {
                    if (selection.type === 'upgrade' || selection.name) {
                        // Try to extract weapon stats
                        const weapon = {
                            name: selection.name,
                            type: selection.type || 'weapon',
                            characteristics: selection.characteristics || [],
                            range: getCharacteristic(selection, 'Range') || '-',
                            attacks: getCharacteristic(selection, 'A') || getCharacteristic(selection, 'Attacks') || '1',
                            skill: getCharacteristic(selection, 'WS') || getCharacteristic(selection, 'BS') || '4+',
                            strength: getCharacteristic(selection, 'S') || getCharacteristic(selection, 'Strength') || '3',
                            ap: getCharacteristic(selection, 'AP') || '0',
                            damage: getCharacteristic(selection, 'D') || getCharacteristic(selection, 'Damage') || '1',
                            keywords: selection.keywords || []
                        };
                        weapons.push(weapon);
                    }
                });
            }
            
            // Check if unit itself has weapon characteristics
            if (unit.characteristics) {
                const hasWeaponStats = unit.characteristics.some(char => 
                    ['Range', 'A', 'Attacks', 'WS', 'BS'].includes(char.name)
                );
                
                if (hasWeaponStats) {
                    const weapon = {
                        name: (unit.name || 'Unit') + ' (Integrated Weapons)',
                        type: 'integrated',
                        characteristics: unit.characteristics,
                        range: getCharacteristic(unit, 'Range') || '-',
                        attacks: getCharacteristic(unit, 'A') || getCharacteristic(unit, 'Attacks') || '1',
                        skill: getCharacteristic(unit, 'WS') || getCharacteristic(unit, 'BS') || '4+',
                        strength: getCharacteristic(unit, 'S') || getCharacteristic(unit, 'Strength') || '3',
                        ap: getCharacteristic(unit, 'AP') || '0',
                        damage: getCharacteristic(unit, 'D') || getCharacteristic(unit, 'Damage') || '1',
                        keywords: unit.keywords || []
                    };
                    weapons.push(weapon);
                }
            }
            
            return weapons;
        }
        
        function getCharacteristic(unit, charName) {
            if (!unit.characteristics) return null;
            const char = unit.characteristics.find(c => c.name === charName);
            return char ? char.value : null;
        }
        
        function createWeaponOption(weapon, index) {
            const option = document.createElement('div');
            option.className = 'weapon-option';
            option.dataset.weaponIndex = index;
            
            option.innerHTML = `
                <input type="checkbox" class="weapon-checkbox" id="weapon-${index}">
                <div class="weapon-info">
                    <div class="weapon-name">${weapon.name}</div>
                    <div class="weapon-stats">
                        <div class="weapon-stat">
                            <div class="weapon-stat-label">Range</div>
                            <div class="weapon-stat-value">${weapon.range}</div>
                        </div>
                        <div class="weapon-stat">
                            <div class="weapon-stat-label">A</div>
                            <div class="weapon-stat-value">${weapon.attacks}</div>
                        </div>
                        <div class="weapon-stat">
                            <div class="weapon-stat-label">Skill</div>
                            <div class="weapon-stat-value">${weapon.skill}</div>
                        </div>
                        <div class="weapon-stat">
                            <div class="weapon-stat-label">S</div>
                            <div class="weapon-stat-value">${weapon.strength}</div>
                        </div>
                        <div class="weapon-stat">
                            <div class="weapon-stat-label">AP</div>
                            <div class="weapon-stat-value">${weapon.ap}</div>
                        </div>
                        <div class="weapon-stat">
                            <div class="weapon-stat-label">D</div>
                            <div class="weapon-stat-value">${weapon.damage}</div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add click handler
            option.addEventListener('click', function(e) {
                if (e.target.type !== 'checkbox') {
                    const checkbox = this.querySelector('.weapon-checkbox');
                    checkbox.checked = !checkbox.checked;
                }
                this.classList.toggle('selected', this.querySelector('.weapon-checkbox').checked);
            });
            
            return option;
        }
        
        function closeWeaponModal() {
            const modal = document.getElementById('weapon-selection-modal');
            modal.style.display = 'none';
            selectedUnitForWeapons = null;
            selectedWeapons = [];
        }
        
        function confirmWeaponSelection() {
            if (!selectedUnitForWeapons) return;
            
            const weaponOptions = document.querySelectorAll('.weapon-option');
            const unit = selectedUnitForWeapons.unit;
            const unitElement = selectedUnitForWeapons.element;
            
            selectedWeapons = [];
            weaponOptions.forEach((option, index) => {
                if (option.querySelector('.weapon-checkbox').checked) {
                    const weapons = extractUnitWeaponsDetailed(unit);
                    if (weapons[index]) {
                        selectedWeapons.push({
                            ...weapons[index],
                            unitName: unit.name,
                            unitId: unit.id || index
                        });
                    }
                }
            });
            
            if (selectedWeapons.length > 0) {
                // Add to selected attackers with weapons
                selectedAttackers.push({
                    unit: unit,
                    weapons: selectedWeapons,
                    selectionRole: 'attacker'
                });
                
                // Mark unit as selected
                unitElement.classList.add('selected');
                updateSelectionSummary('attacker');
                validateCurrentStep();
                
                showNotification(`Selected ${selectedWeapons.length} weapons from ${unit.name}`, 'success');
            } else {
                showNotification('Please select at least one weapon', 'warning');
                return;
            }
            
            closeWeaponModal();
        }
        
        function createUnitSelectionHTML(roster, role) {
            if (!roster || !roster.forces) {
                return '<div class="no-units">Keine Einheiten in diesem Roster gefunden.</div>';
            }
            
            let html = '';
            let unitCount = 0;
            
            roster.forces.forEach(force => {
                if (force.selections && force.selections.length > 0) {
                    html += `
                        <div class="unit-category">
                            <div class="category-header">
                                <h3><i class="material-icons" aria-hidden="true">military_tech</i> ${force.name || 'Unbenannte Einheit'}</h3>
                                <div class="category-count">${force.selections.length} Einheiten</div>
                            </div>
                            <div class="unit-list">
                    `;
                    
                    force.selections.forEach((unit, index) => {
                        const unitId = `${role}-unit-${unitCount}`;
                        const stats = extractUnitStats(unit);
                        const weapons = extractUnitWeapons(unit);
                        const keywords = extractUnitKeywords(unit);
                        
                        html += `
                            <div class="unit-item" data-unit-id="${unitId}" data-role="${role}" data-unit-index="${unitCount}">
                                <div class="unit-info">
                                    <div class="unit-header">
                                        <h4 class="unit-name">${unit.name || 'Unbenannte Einheit'}</h4>
                                        <div class="unit-cost">${unit.cost || 0} Pts</div>
                                    </div>
                                    
                                    ${stats.length > 0 ? `
                                        <div class="unit-stats">
                                            ${stats.map(stat => `
                                                <div class="stat-item">
                                                    <div class="stat-label">${stat.label}</div>
                                                    <div class="stat-value">${stat.value}</div>
                                                </div>
                                            `).join('')}
                                        </div>
                                    ` : ''}
                                    
                                    ${weapons.length > 0 ? `
                                        <div class="unit-weapons">
                                            <div class="weapon-count">${weapons.length} Waffe(n)</div>
                                            <div class="weapon-list">
                                                ${weapons.map(weapon => `
                                                    <span class="weapon-tag">${weapon}</span>
                                                `).join('')}
                                            </div>
                                        </div>
                                    ` : ''}
                                    
                                    ${keywords.length > 0 ? `
                                        <div class="unit-keywords">
                                            <div class="keyword-count">${keywords.length} Keyword(s)</div>
                                            <div class="keyword-list">
                                                ${keywords.map(keyword => `
                                                    <span class="keyword-tag">${keyword}</span>
                                                `).join('')}
                                            </div>
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        `;
                        
                        unitCount++;
                    });
                    
                    html += `
                            </div>
                            <div class="selection-actions">
                                <button class="select-all-btn" onclick="selectAllInCategory('${role}', ${force.selections.length})">
                                    <i class="material-icons" aria-hidden="true">select_all</i>
                                    Alle auswählen
                                </button>
                                <button class="clear-selection-btn" onclick="clearCategorySelection('${role}')">
                                    <i class="material-icons" aria-hidden="true">clear</i>
                                    Auswahl löschen
                                </button>
                            </div>
                        </div>
                    `;
                }
            });
            
            return html;
        }
        
        function extractUnitStats(unit) {
            const stats = [];
            
            // Standard 40k Stats
            if (unit.characteristics) {
                unit.characteristics.forEach(char => {
                    stats.push({
                        label: char.name,
                        value: char.value
                    });
                });
            }
            
            // Fallback für andere Strukturen
            ['M', 'WS', 'BS', 'S', 'T', 'W', 'A', 'Ld', 'Save'].forEach(statName => {
                if (unit[statName] !== undefined) {
                    stats.push({
                        label: statName,
                        value: unit[statName]
                    });
                }
            });
            
            return stats;
        }
        
        function extractUnitWeapons(unit) {
            const weapons = [];
            
            if (unit.selections) {
                unit.selections.forEach(selection => {
                    if (selection.type === 'upgrade' && selection.name) {
                        weapons.push(selection.name);
                    }
                });
            }
            
            if (unit.weapons) {
                unit.weapons.forEach(weapon => {
                    if (weapon.name) {
                        weapons.push(weapon.name);
                    }
                });
            }
            
            return weapons;
        }
        
        function extractUnitKeywords(unit) {
            const keywords = new Set();
            
            if (unit.keywords) {
                if (Array.isArray(unit.keywords)) {
                    unit.keywords.forEach(keyword => keywords.add(keyword.trim()));
                } else if (typeof unit.keywords === 'string') {
                    unit.keywords.split(',').forEach(keyword => keywords.add(keyword.trim()));
                }
            }
            
            // Check for assigned custom keywords
            const unitId = unit.id;
            if (keywordAssignments.has(unitId)) {
                keywordAssignments.get(unitId).forEach(keyword => keywords.add(keyword));
            }
            
            return Array.from(keywords).filter(k => k.length > 0);
        }
        
        function toggleUnitSelection(unitElement) {
            const isSelected = unitElement.classList.contains('selected');
            const role = unitElement.dataset.role;
            
            if (isSelected) {
                unitElement.classList.remove('selected');
            } else {
                unitElement.classList.add('selected');
            }
            
            updateSelectionSummary(role);
            
            // Announce to screen reader
            const unitName = unitElement.querySelector('.unit-name').textContent;
            const action = isSelected ? 'abgewählt' : 'ausgewählt';
            announceToScreenReader(`${unitName} ${action}`);
        }
        
        function selectAllInCategory(role, count) {
            const roleSelector = role === 'attacker' ? '#attacker-units' : '#defender-units';
            const unitItems = document.querySelectorAll(`${roleSelector} .unit-item`);
            
            unitItems.forEach(item => {
                item.classList.add('selected');
            });
            
            updateSelectionSummary(role);
            showNotification(`Alle ${count} Einheiten ausgewählt.`, 'success');
        }
        
        function clearCategorySelection(role) {
            const roleSelector = role === 'attacker' ? '#attacker-units' : '#defender-units';
            const unitItems = document.querySelectorAll(`${roleSelector} .unit-item.selected`);
            const count = unitItems.length;
            
            unitItems.forEach(item => {
                item.classList.remove('selected');
            });
            
            updateSelectionSummary(role);
            if (count > 0) {
                showNotification(`${count} Einheiten abgewählt.`, 'success');
            }
        }
        
        function updateSelectionSummary(role) {
            const roleSelector = role === 'attacker' ? '#attacker-units' : '#defender-units';
            const selectedItems = document.querySelectorAll(`${roleSelector} .unit-item.selected`);
            const totalItems = document.querySelectorAll(`${roleSelector} .unit-item`);
            
            const summaryElement = document.querySelector(`#${role}-selection-summary`);
            if (summaryElement) {
                summaryElement.innerHTML = `
                    <div class="selection-count">
                        <div class="count-item">
                            <span class="count-number">${selectedItems.length}</span>
                            <span class="count-label">Ausgewählt</span>
                        </div>
                        <div class="count-item">
                            <span class="count-number">${totalItems.length}</span>
                            <span class="count-label">Verfügbar</span>
                        </div>
                    </div>
                `;
            }
        }
        
        function displayAttackerUnits() {
            const container = document.getElementById('attacker-units');
            if (!container || !attackerRoster) return;
            
            container.innerHTML = '';
            
            const allAttackerUnits = [...attackerRoster.weapons, ...attackerRoster.defenders];
            
            if (allAttackerUnits.length === 0) {
                container.innerHTML = `
                    <div class="unit-empty">
                        <i class="material-icons" aria-hidden="true">info</i>
                        <p>Keine Angreifer-Einheiten im Roster gefunden.</p>
                    </div>
                `;
                return;
            }
            
            allAttackerUnits.forEach(unit => {
                const unitCard = createSelectableUnitCard(unit, 'attacker');
                container.appendChild(unitCard);
            });
            
            announceToScreenReader(`${allAttackerUnits.length} Angreifer-Einheiten verfügbar`);
        }
        
        function displayDefenderUnits() {
            const container = document.getElementById('defender-units');
            if (!container || !defenderRoster) return;
            
            container.innerHTML = '';
            
            // Only use defenders from defender roster for defensive units
            const defenderUnits = defenderRoster.defenders;
            
            if (defenderUnits.length === 0) {
                container.innerHTML = `
                    <div class="unit-empty">
                        <i class="material-icons" aria-hidden="true">info</i>
                        <p>Keine Verteidiger-Einheiten im Roster gefunden.</p>
                    </div>
                `;
                return;
            }
            
            defenderUnits.forEach(unit => {
                const unitCard = createSelectableUnitCard(unit, 'defender');
                container.appendChild(unitCard);
            });
            
            announceToScreenReader(`${defenderUnits.length} Verteidiger-Einheiten verfügbar`);
        }
        
        function createSelectableUnitCard(unit, role) {
            const card = document.createElement('div');
            card.className = 'unit-card selectable';
            card.setAttribute('data-unit-id', unit.id);
            card.setAttribute('data-role', role);
            card.setAttribute('role', 'button');
            card.setAttribute('tabindex', '0');
            card.setAttribute('aria-label', `${unit.name} auswählen`);
            
            // Determine if unit is a weapon or defender
            const isWeapon = unit.attacks !== undefined;
            const typeIcon = isWeapon ? 
                (unit.type === 'Melee' ? 'sports_martial_arts' : 'gps_fixed') :
                (unit.type === 'Vehicle' ? 'directions_car' : 
                 unit.type === 'Monster' ? 'pest_control' : 
                 unit.type === 'Character' ? 'person' : 'groups');
            
            const keywords = unit.keywords || '';
            const keywordTags = keywords ? 
                keywords.split(',').map(k => `<span class="keyword-mini">${k.trim()}</span>`).join('') : 
                '<span class="keyword-mini no-keywords">Keine Keywords</span>';
            
            // Create stats display based on unit type
            let statsDisplay = '';
            if (isWeapon) {
                statsDisplay = `
                    <div class="unit-stats">
                        <div class="stat"><span class="stat-label">A:</span> ${unit.attacks}</div>
                        <div class="stat"><span class="stat-label">H:</span> ${unit.skill}+</div>
                        <div class="stat"><span class="stat-label">S:</span> ${unit.strength}</div>
                        <div class="stat"><span class="stat-label">AP:</span> -${unit.ap}</div>
                        <div class="stat"><span class="stat-label">D:</span> ${unit.damage}</div>
                    </div>
                `;
            } else {
                const saveText = unit.save === 7 ? '-' : `${unit.save}+`;
                const invulnText = unit.invulnSave ? `${unit.invulnSave}++` : '-';
                const fnpText = unit.feelNoPain ? `${unit.feelNoPain}+++` : '-';
                
                statsDisplay = `
                    <div class="unit-stats">
                        <div class="stat"><span class="stat-label">T:</span> ${unit.toughness}</div>
                        <div class="stat"><span class="stat-label">RW:</span> ${saveText}</div>
                        <div class="stat"><span class="stat-label">UW:</span> ${invulnText}</div>
                        <div class="stat"><span class="stat-label">W:</span> ${unit.wounds}</div>
                        <div class="stat"><span class="stat-label">FNP:</span> ${fnpText}</div>
                    </div>
                `;
            }
            
            card.innerHTML = `
                <div class="unit-header">
                    <div class="unit-title">
                        <i class="material-icons unit-icon" aria-hidden="true">${typeIcon}</i>
                        <span class="unit-name">${unit.name}</span>
                        <span class="unit-type-badge">${isWeapon ? 'Waffe' : 'Einheit'}</span>
                    </div>
                    <div class="unit-select-checkbox">
                        <i class="material-icons" aria-hidden="true">add_circle_outline</i>
                    </div>
                </div>
                ${statsDisplay}
                <div class="unit-keywords">
                    ${keywordTags}
                </div>
            `;
            
            // Add click handler
            card.addEventListener('click', () => selectUnit(unit, role));
            card.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    selectUnit(unit, role);
                }
            });
            
            return card;
        }
        
        function selectUnit(unit, role) {
            const isWeapon = unit.attacks !== undefined;
            const targetArray = role === 'attacker' ? selectedAttackers : selectedDefenders;
            
            // Check if already selected
            if (targetArray.find(u => u.id === unit.id)) {
                showErrorToast(`Diese ${isWeapon ? 'Waffe' : 'Einheit'} ist bereits ausgewählt`);
                return;
            }
            
            // Add to selection
            targetArray.push({ ...unit, selectionRole: role });
            
            // Update displays
            updateSelectedUnitsDisplay();
            updateUnitCardSelection(unit.id, true);
            validateCurrentStep();
            
            const unitType = isWeapon ? 'Waffe' : 'Einheit';
            announceToScreenReader(`${unitType} ${unit.name} als ${role === 'attacker' ? 'Angreifer' : 'Verteidiger'} ausgewählt`);
        }
        
        function unselectUnit(unitId, role) {
            const targetArray = role === 'attacker' ? selectedAttackers : selectedDefenders;
            const unit = targetArray.find(u => u.id === unitId);
            
            if (!unit) return;
            
            // Remove from selection
            if (role === 'attacker') {
                selectedAttackers = selectedAttackers.filter(u => u.id !== unitId);
            } else {
                selectedDefenders = selectedDefenders.filter(u => u.id !== unitId);
            }
            
            // Update displays
            updateSelectedUnitsDisplay();
            updateUnitCardSelection(unitId, false);
            validateCurrentStep();
            
            const unitType = unit.attacks !== undefined ? 'Waffe' : 'Einheit';
            announceToScreenReader(`${unitType} ${unit.name} entfernt`);
        }
        
        function updateUnitCardSelection(unitId, isSelected) {
            const unitCard = document.querySelector(`[data-unit-id="${unitId}"]`);
            if (!unitCard) return;
            
            const checkbox = unitCard.querySelector('.unit-select-checkbox i');
            
            if (isSelected) {
                unitCard.classList.add('selected');
                checkbox.textContent = 'check_circle';
                unitCard.setAttribute('aria-label', unitCard.getAttribute('aria-label').replace('auswählen', 'abwählen'));
            } else {
                unitCard.classList.remove('selected');
                checkbox.textContent = 'add_circle_outline';
                unitCard.setAttribute('aria-label', unitCard.getAttribute('aria-label').replace('abwählen', 'auswählen'));
            }
        }
        
        function updateSelectedUnitsDisplay() {
            updateSelectedAttackersDisplay();
            updateSelectedDefendersDisplay();
        }
        
        function updateSelectedAttackersDisplay() {
            const container = document.getElementById('selected-attackers');
            if (!container) return;
            
            container.innerHTML = '<h4>Ausgewählte Angreifer</h4>';
            
            if (selectedAttackers.length === 0) {
                container.innerHTML += `
                    <div class="selected-empty">
                        <i class="material-icons" aria-hidden="true">info</i>
                        <p>Keine Angreifer ausgewählt</p>
                    </div>
                `;
                return;
            }
            
            selectedAttackers.forEach(unit => {
                const unitSummary = createSelectedUnitSummary(unit, 'attacker');
                container.appendChild(unitSummary);
            });
        }
        
        function updateSelectedDefendersDisplay() {
            const container = document.getElementById('selected-defenders');
            if (!container) return;
            
            container.innerHTML = '<h4>Ausgewählte Verteidiger</h4>';
            
            if (selectedDefenders.length === 0) {
                container.innerHTML += `
                    <div class="selected-empty">
                        <i class="material-icons" aria-hidden="true">info</i>
                        <p>Keine Verteidiger ausgewählt</p>
                    </div>
                `;
                return;
            }
            
            selectedDefenders.forEach(unit => {
                const unitSummary = createSelectedUnitSummary(unit, 'defender');
                container.appendChild(unitSummary);
            });
        }
        
        function createSelectedUnitSummary(unit, role) {
            const summary = document.createElement('div');
            summary.className = 'selected-unit-summary';
            summary.setAttribute('data-unit-id', unit.id);
            
            const isWeapon = unit.attacks !== undefined;
            const typeIcon = isWeapon ? 
                (unit.type === 'Melee' ? 'sports_martial_arts' : 'gps_fixed') :
                (unit.type === 'Vehicle' ? 'directions_car' : 
                 unit.type === 'Monster' ? 'pest_control' : 
                 unit.type === 'Character' ? 'person' : 'groups');
            
            summary.innerHTML = `
                <div class="summary-header">
                    <i class="material-icons" aria-hidden="true">${typeIcon}</i>
                    <span class="summary-name">${unit.name}</span>
                    <button 
                        class="btn btn-icon btn-small"
                        onclick="unselectUnit(${unit.id}, '${role}')"
                        aria-label="${unit.name} entfernen"
                        title="Aus Auswahl entfernen"
                    >
                        <i class="material-icons" aria-hidden="true">close</i>
                    </button>
                </div>
                <div class="summary-type">${isWeapon ? 'Waffe' : 'Einheit'} • ${unit.type}</div>
            `;
            
            return summary;
        }
        
        function filterUnits(role) {
            const searchInput = document.getElementById(`${role}-search`);
            const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
            const container = document.getElementById(`${role}-units`);
            
            if (!container) return;
            
            const unitCards = container.querySelectorAll('.unit-card');
            let visibleCount = 0;
            
            unitCards.forEach(card => {
                const unitName = card.querySelector('.unit-name').textContent.toLowerCase();
                const keywords = Array.from(card.querySelectorAll('.keyword-mini'))
                    .map(tag => tag.textContent.toLowerCase())
                    .join(' ');
                
                const isVisible = unitName.includes(searchTerm) || keywords.includes(searchTerm);
                card.style.display = isVisible ? 'block' : 'none';
                
                if (isVisible) visibleCount++;
            });
            
            announceToScreenReader(`${visibleCount} ${role === 'attacker' ? 'Angreifer' : 'Verteidiger'} gefunden`);
        }

        // ===== ADVANCED SIMULATION SYSTEM =====
        
        function prepareBattleSimulation() {
            generateBattlePreview();
            validateSimulationSettings();
            announceToScreenReader('Schlacht-Konfiguration geladen');
        }
        
        function generateBattlePreview() {
            const previewContainer = document.getElementById('battle-preview');
            if (!previewContainer) return;
            
            const totalAttackers = selectedAttackers.length;
            const totalDefenders = selectedDefenders.length;
            
            if (totalAttackers === 0 || totalDefenders === 0) {
                previewContainer.innerHTML = `
                    <div class="preview-empty">
                        <i class="material-icons" aria-hidden="true">warning</i>
                        <p>Keine Einheiten für die Schlacht ausgewählt</p>
                        <p class="text-muted">Gehen Sie zurück zu Schritt 3 um Einheiten auszuwählen</p>
                    </div>
                `;
                return;
            }
            
            // Separate weapons and defenders for detailed preview
            const attackerWeapons = selectedAttackers.filter(u => u.attacks !== undefined);
            const attackerUnits = selectedAttackers.filter(u => u.attacks === undefined);
            const defenderUnits = selectedDefenders;
            
            // Calculate estimated battle metrics
            const totalAttacks = attackerWeapons.reduce((sum, w) => {
                const attacks = typeof w.attacks === 'string' ? 
                    (w.attacks.includes('D') ? 3.5 : parseInt(w.attacks) || 1) : 
                    w.attacks || 1;
                return sum + attacks;
            }, 0);
            
            const totalWounds = defenderUnits.reduce((sum, d) => sum + (d.wounds || 1), 0);
            const avgToughness = defenderUnits.reduce((sum, d) => sum + (d.toughness || 4), 0) / defenderUnits.length;
            const avgSave = defenderUnits.reduce((sum, d) => sum + (d.save === 7 ? 7 : d.save || 3), 0) / defenderUnits.length;
            
            previewContainer.innerHTML = `
                <div class="battle-stats">
                    <div class="battle-stat-group">
                        <h4><i class="material-icons" aria-hidden="true">gps_fixed</i> Angriffskraft</h4>
                        <div class="stat-grid">
                            <div class="stat-item">
                                <span class="stat-value">${attackerWeapons.length}</span>
                                <span class="stat-label">Waffen</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value">${Math.round(totalAttacks)}</span>
                                <span class="stat-label">Ø Angriffe</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value">${attackerUnits.length}</span>
                                <span class="stat-label">Support-Einheiten</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="battle-stat-group">
                        <h4><i class="material-icons" aria-hidden="true">shield</i> Verteidigung</h4>
                        <div class="stat-grid">
                            <div class="stat-item">
                                <span class="stat-value">${defenderUnits.length}</span>
                                <span class="stat-label">Einheiten</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value">${totalWounds}</span>
                                <span class="stat-label">LP Total</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value">${avgToughness.toFixed(1)} / ${avgSave.toFixed(1)}+</span>
                                <span class="stat-label">Ø T / RW</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="battle-units">
                    <div class="battle-unit-list">
                        <h5>Ausgewählte Waffen (${attackerWeapons.length})</h5>
                        <div class="unit-chips">
                            ${attackerWeapons.map(w => `
                                <span class="unit-chip weapon">${w.name}</span>
                            `).join('')}
                        </div>
                    </div>
                    
                    <div class="battle-unit-list">
                        <h5>Ziel-Einheiten (${defenderUnits.length})</h5>
                        <div class="unit-chips">
                            ${defenderUnits.map(d => `
                                <span class="unit-chip defender">${d.name}</span>
                            `).join('')}
                        </div>
                    </div>
                </div>
                
                <div class="battle-estimation">
                    <div class="estimation-card">
                        <h5><i class="material-icons" aria-hidden="true">trending_up</i> Kampf-Prognose</h5>
                        <p class="text-muted">
                            Geschätzte Simulation mit ${document.getElementById('iterations')?.value || 100000} Iterationen.
                            Ergebnis verfügbar in ca. ${Math.ceil((totalAttackers * totalDefenders) / 10000)} Sekunden.
                        </p>
                    </div>
                </div>
            `;
        }
        
        function validateSimulationSettings() {
            const iterations = parseInt(document.getElementById('iterations')?.value) || 100000;
            const runBtn = document.getElementById('run-simulation');
            
            if (iterations < 1000 || iterations > 1000000) {
                runBtn.disabled = true;
                runBtn.title = 'Iterationen müssen zwischen 1.000 und 1.000.000 liegen';
            } else if (selectedAttackers.length === 0 || selectedDefenders.length === 0) {
                runBtn.disabled = true;
                runBtn.title = 'Angreifer und Verteidiger müssen ausgewählt sein';
            } else {
                runBtn.disabled = false;
                runBtn.title = 'Schlacht starten';
            }
        }
        
        async function runAdvancedSimulation() {
            // Validation
            if (selectedAttackers.length === 0 || selectedDefenders.length === 0) {
                showErrorToast('Bitte wählen Sie Angreifer und Verteidiger aus');
                return;
            }
            
            const iterations = parseInt(document.getElementById('iterations')?.value) || 100000;
            const detailedAnalysis = document.getElementById('detailed-analysis')?.checked || false;
            const autoExport = document.getElementById('auto-export')?.checked || false;
            
            if (iterations < 1000 || iterations > 1000000) {
                showErrorToast('Anzahl Iterationen muss zwischen 1.000 und 1.000.000 liegen');
                return;
            }
            
            showLoadingOverlay('Kampfsimulation wird vorbereitet...');
            
            try {
                // Prepare simulation data
                const attackerWeapons = selectedAttackers.filter(u => u.attacks !== undefined);
                const defenderUnits = selectedDefenders;
                
                if (attackerWeapons.length === 0) {
                    throw new Error('Keine Waffen zum Angriff ausgewählt');
                }
                
                const simulationData = {
                    weapons: attackerWeapons,
                    defenders: defenderUnits,
                    iterations: iterations,
                    detailedAnalysis: detailedAnalysis,
                    autoExport: autoExport,
                    timestamp: new Date().toISOString(),
                    keywords: Array.from(availableKeywords)
                };
                
                // Run the advanced simulation
                const results = await executeAdvancedSimulation(simulationData);
                
                // Store results globally
                currentResults = results;
                
                // Navigate to results step
                goToStep('results');
                
                // Auto-export if requested
                if (autoExport) {
                    setTimeout(() => exportResults(), 1000);
                }
                
                announceToScreenReader('Kampfsimulation erfolgreich abgeschlossen');
                
            } catch (error) {
                console.error('Advanced simulation error:', error);
                showErrorToast(`Fehler bei der Simulation: ${error.message}`);
            } finally {
                hideLoadingOverlay();
            }
        }
        
        async function executeAdvancedSimulation(simulationData) {
            const { weapons, defenders, iterations, detailedAnalysis } = simulationData;
            
            // Update loading overlay with progress
            const updateProgress = (current, total, phase) => {
                const progressElement = document.getElementById('loading-progress');
                if (progressElement) {
                    const percentage = Math.round((current / total) * 100);
                    progressElement.textContent = `${phase}: ${percentage}% (${current.toLocaleString()}/${total.toLocaleString()})`;
                }
            };
            
            const results = {
                ...simulationData,
                combatResults: [],
                statistics: {
                    totalDamageDealt: 0,
                    totalHits: 0,
                    totalAttacks: 0,
                    averageDamagePerRound: 0,
                    killProbability: {},
                    weaponEffectiveness: {},
                    defenderSurvival: {}
                },
                detailedBreakdown: detailedAnalysis ? {} : null
            };
            
            // Simulate each weapon against each defender
            const totalCombinations = weapons.length * defenders.length;
            let currentCombination = 0;
            
            updateProgress(0, iterations, 'Initialisierung');
            
            for (const weapon of weapons) {
                results.statistics.weaponEffectiveness[weapon.name] = {
                    totalDamage: 0,
                    totalHits: 0,
                    averageDamagePerHit: 0,
                    hitRate: 0
                };
                
                for (const defender of defenders) {
                    currentCombination++;
                    updateProgress(currentCombination * 1000, totalCombinations * iterations, 'Kampfsimulation');
                    
                    const combatResult = await simulateCombat(weapon, defender, iterations, updateProgress);
                    results.combatResults.push(combatResult);
                    
                    // Aggregate statistics
                    results.statistics.totalDamageDealt += combatResult.totalDamage;
                    results.statistics.totalHits += combatResult.totalHits;
                    results.statistics.totalAttacks += combatResult.totalAttacks;
                    
                    // Update weapon effectiveness
                    const weaponStats = results.statistics.weaponEffectiveness[weapon.name];
                    weaponStats.totalDamage += combatResult.totalDamage;
                    weaponStats.totalHits += combatResult.totalHits;
                    
                    // Initialize defender survival if not exists
                    if (!results.statistics.defenderSurvival[defender.name]) {
                        results.statistics.defenderSurvival[defender.name] = {
                            damageReceived: 0,
                            survivalRate: 0,
                            averageWoundsRemaining: 0
                        };
                    }
                    
                    const defenderStats = results.statistics.defenderSurvival[defender.name];
                    defenderStats.damageReceived += combatResult.totalDamage;
                    defenderStats.survivalRate = combatResult.survivalRate;
                    defenderStats.averageWoundsRemaining = combatResult.averageWoundsRemaining;
                    
                    // Detailed breakdown if requested
                    if (detailedAnalysis) {
                        const key = `${weapon.name}_vs_${defender.name}`;
                        results.detailedBreakdown[key] = {
                            weapon: weapon.name,
                            defender: defender.name,
                            damageDistribution: combatResult.damageDistribution,
                            hitDistribution: combatResult.hitDistribution,
                            criticalHits: combatResult.criticalHits || 0
                        };
                    }
                }
            }
            
            // Calculate final statistics
            results.statistics.averageDamagePerRound = results.statistics.totalDamageDealt / iterations;
            
            // Calculate weapon effectiveness averages
            for (const weaponName in results.statistics.weaponEffectiveness) {
                const stats = results.statistics.weaponEffectiveness[weaponName];
                stats.averageDamagePerHit = stats.totalHits > 0 ? stats.totalDamage / stats.totalHits : 0;
                stats.hitRate = results.statistics.totalAttacks > 0 ? stats.totalHits / results.statistics.totalAttacks : 0;
            }
            
            updateProgress(iterations, iterations, 'Analyse abgeschlossen');
            
            return results;
        }
        
        async function simulateCombat(weapon, defender, iterations, updateProgress) {
            const result = {
                weapon: weapon.name,
                defender: defender.name,
                totalDamage: 0,
                totalHits: 0,
                totalAttacks: 0,
                survivalRate: 0,
                averageWoundsRemaining: 0,
                damageDistribution: {},
                hitDistribution: {},
                killCount: 0
            };
            
            // Parse weapon stats
            const attacks = typeof weapon.attacks === 'string' ? 
                (weapon.attacks.includes('D') ? Math.floor(Math.random() * 6) + 1 : parseInt(weapon.attacks)) : 
                weapon.attacks;
            const hitThreshold = weapon.skill || 4;
            const strength = weapon.strength || 4;
            const ap = weapon.ap || 0;
            const damage = typeof weapon.damage === 'string' ? 
                (weapon.damage.includes('D') ? Math.floor(Math.random() * 6) + 1 : parseInt(weapon.damage)) : 
                weapon.damage;
            
            // Parse defender stats
            const toughness = defender.toughness || 4;
            const save = defender.save || 3;
            const invulnSave = defender.invulnSave;
            const wounds = defender.wounds || 1;
            const feelNoPain = defender.feelNoPain;
            
            // Calculate wound threshold
            let woundThreshold = 4;
            if (strength >= toughness * 2) woundThreshold = 2;
            else if (strength > toughness) woundThreshold = 3;
            else if (strength === toughness) woundThreshold = 4;
            else if (strength * 2 <= toughness) woundThreshold = 6;
            else woundThreshold = 5;
            
            // Run simulation iterations
            for (let i = 0; i < iterations; i++) {
                if (i % 10000 === 0 && updateProgress) {
                    updateProgress(i, iterations, `${weapon.name} vs ${defender.name}`);
                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
                
                let defenderWounds = wounds;
                let totalDamageThisRound = 0;
                let hitsThisRound = 0;
                
                // Roll attacks
                for (let attack = 0; attack < attacks; attack++) {
                    result.totalAttacks++;
                    
                    // Hit roll
                    const hitRoll = Math.floor(Math.random() * 6) + 1;
                    if (hitRoll < hitThreshold) continue;
                    
                    result.totalHits++;
                    hitsThisRound++;
                    
                    // Wound roll
                    const woundRoll = Math.floor(Math.random() * 6) + 1;
                    if (woundRoll < woundThreshold) continue;
                    
                    // Save roll
                    const effectiveSave = Math.max(save + ap, invulnSave || 7);
                    if (effectiveSave <= 6) {
                        const saveRoll = Math.floor(Math.random() * 6) + 1;
                        if (saveRoll >= effectiveSave) continue;
                    }
                    
                    // Feel No Pain
                    if (feelNoPain) {
                        const fnpRoll = Math.floor(Math.random() * 6) + 1;
                        if (fnpRoll >= feelNoPain) continue;
                    }
                    
                    // Apply damage
                    const actualDamage = Math.min(damage, defenderWounds);
                    defenderWounds -= actualDamage;
                    totalDamageThisRound += actualDamage;
                    result.totalDamage += actualDamage;
                    
                    if (defenderWounds <= 0) {
                        result.killCount++;
                        break;
                    }
                }
                
                // Track distributions
                result.damageDistribution[totalDamageThisRound] = (result.damageDistribution[totalDamageThisRound] || 0) + 1;
                result.hitDistribution[hitsThisRound] = (result.hitDistribution[hitsThisRound] || 0) + 1;
                
                // Track survival
                if (defenderWounds > 0) {
                    result.averageWoundsRemaining += defenderWounds;
                }
            }
            
            // Calculate final statistics
            result.survivalRate = (iterations - result.killCount) / iterations;
            result.averageWoundsRemaining = result.averageWoundsRemaining / Math.max(iterations - result.killCount, 1);
            
            return result;
        }

        // ===== RESULTS DASHBOARD & ANALYTICS =====
        
        function displaySimulationResults() {
            if (!currentResults) {
                showErrorToast('Keine Simulationsergebnisse verfügbar');
                return;
            }
            
            console.log('Displaying simulation results:', currentResults);
            
            // Generate comprehensive results display
            generateResultsSummary();
            generateDetailedAnalytics();
            generateDataVisualization();
            generateExportOptions();
            
            announceToScreenReader('Simulationsergebnisse erfolgreich geladen');
        }
        
        function generateResultsSummary() {
            const summaryContainer = document.getElementById('results-summary');
            if (!summaryContainer) return;
            
            const { statistics, combatResults, weapons, defenders, iterations } = currentResults;
            
            // Calculate key metrics
            const totalCombinations = combatResults.length;
            const averageDamagePerIteration = statistics.totalDamageDealt / iterations;
            const overallHitRate = statistics.totalAttacks > 0 ? (statistics.totalHits / statistics.totalAttacks * 100) : 0;
            const totalDefenderWounds = defenders.reduce((sum, d) => sum + (d.wounds || 1), 0);
            const damageEfficiency = totalDefenderWounds > 0 ? (averageDamagePerIteration / totalDefenderWounds * 100) : 0;
            
            // Find most/least effective combinations based on average damage
            const sortedResults = [...combatResults].sort((a, b) => (b.totalDamage / iterations) - (a.totalDamage / iterations));
            const mostEffective = sortedResults[0];
            const leastEffective = sortedResults[sortedResults.length - 1];
            
            summaryContainer.innerHTML = `
                <div class="results-header">
                    <div class="results-title">
                        <h3><i class="material-icons" aria-hidden="true">analytics</i> Simulationsergebnisse</h3>
                        <div class="results-meta">
                            <span class="meta-item">
                                <i class="material-icons" aria-hidden="true">repeat</i>
                                ${iterations.toLocaleString()} Iterationen
                            </span>
                            <span class="meta-item">
                                <i class="material-icons" aria-hidden="true">schedule</i>
                                ${new Date(currentResults.timestamp).toLocaleString()}
                            </span>
                            <span class="meta-item">
                                <i class="material-icons" aria-hidden="true">memory</i>
                                ${totalCombinations} Kampf-Kombinationen
                            </span>
                        </div>
                    </div>
                </div>
                
                <div class="results-grid">
                    <div class="result-card primary">
                        <div class="card-header">
                            <i class="material-icons" aria-hidden="true">trending_up</i>
                            <h4>Average Damage</h4>
                        </div>
                        <div class="card-content">
                            <div class="primary-metric">${averageDamagePerIteration.toFixed(2)}</div>
                            <div class="metric-subtitle">Per Simulation Round</div>
                            <div class="metric-detail">From ${iterations.toLocaleString()} Iterations</div>
                        </div>
                    </div>
                    
                    <div class="result-card">
                        <div class="card-header">
                            <i class="material-icons" aria-hidden="true">gps_fixed</i>
                            <h4>Hit Rate</h4>
                        </div>
                        <div class="card-content">
                            <div class="primary-metric">${overallHitRate.toFixed(1)}%</div>
                            <div class="metric-subtitle">${statistics.totalHits.toLocaleString()} / ${statistics.totalAttacks.toLocaleString()} Hits</div>
                        </div>
                    </div>
                    
                    <div class="result-card">
                        <div class="card-header">
                            <i class="material-icons" aria-hidden="true">healing</i>
                            <h4>Wound Rate</h4>
                        </div>
                        <div class="card-content">
                            <div class="primary-metric">${statistics.totalHits > 0 ? ((statistics.totalWounds / statistics.totalHits) * 100).toFixed(1) : 0}%</div>
                            <div class="metric-subtitle">${statistics.totalWounds.toLocaleString()} / ${statistics.totalHits.toLocaleString()} Wounds</div>
                        </div>
                    </div>
                    
                    <div class="result-card">
                        <div class="card-header">
                            <i class="material-icons" aria-hidden="true">shield</i>
                            <h4>Save Failures</h4>
                        </div>
                        <div class="card-content">
                            <div class="primary-metric">${statistics.totalWounds > 0 ? ((statistics.totalFailedSaves / statistics.totalWounds) * 100).toFixed(1) : 0}%</div>
                            <div class="metric-subtitle">${statistics.totalFailedSaves.toLocaleString()} / ${statistics.totalWounds.toLocaleString()} Failed</div>
                        </div>
                    </div>
                    
                    <div class="result-card">
                        <div class="card-header">
                            <i class="material-icons" aria-hidden="true">favorite</i>
                            <h4>Feel No Pain</h4>
                        </div>
                        <div class="card-content">
                            <div class="primary-metric">${statistics.totalFailedSaves > 0 ? ((statistics.totalFNPSaves / statistics.totalFailedSaves) * 100).toFixed(1) : 0}%</div>
                            <div class="metric-subtitle">${statistics.totalFNPSaves.toLocaleString()} / ${statistics.totalFailedSaves.toLocaleString()} FNP Saves</div>
                        </div>
                    </div>
                    
                    <div class="result-card">
                        <div class="card-header">
                            <i class="material-icons" aria-hidden="true">speed</i>
                            <h4>Damage Efficiency</h4>
                        </div>
                        <div class="card-content">
                            <div class="primary-metric">${damageEfficiency.toFixed(1)}%</div>
                            <div class="metric-subtitle">Relative Lethality</div>
                        </div>
                    </div>
                    
                    <div class="result-card">
                        <div class="card-header">
                            <i class="material-icons" aria-hidden="true">military_tech</i>
                            <h4>Best Unit Combination</h4>
                        </div>
                        <div class="card-content">
                            <div class="combo-display">
                                <div class="combo-weapon">${mostEffective.weapon}</div>
                                <i class="material-icons combo-arrow" aria-hidden="true">arrow_forward</i>
                                <div class="combo-target">${mostEffective.defender}</div>
                            </div>
                            <div class="metric-detail">${(mostEffective.totalDamage / iterations).toFixed(2)} Ø Schaden</div>
                        </div>
                    </div>
                </div>
                
                <div class="battlefield-overview">
                    <h4><i class="material-icons" aria-hidden="true">map</i> Schlachtfeld-Übersicht</h4>
                    <div class="battlefield-stats">
                        <div class="battlefield-section">
                            <h5>Angriffskräfte</h5>
                            <div class="force-list">
                                ${weapons.map(w => `
                                    <div class="force-item weapon">
                                        <i class="material-icons" aria-hidden="true">${w.type === 'Melee' ? 'sports_martial_arts' : 'gps_fixed'}</i>
                                        <span>${w.name}</span>
                                        <div class="force-stats">A${w.attacks} S${w.strength} AP-${w.ap} D${w.damage}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div class="battlefield-section">
                            <h5>Verteidigende Einheiten</h5>
                            <div class="force-list">
                                ${defenders.map(d => `
                                    <div class="force-item defender">
                                        <i class="material-icons" aria-hidden="true">${d.type === 'Vehicle' ? 'directions_car' : d.type === 'Monster' ? 'pest_control' : 'groups'}</i>
                                        <span>${d.name}</span>
                                        <div class="force-stats">T${d.toughness} ${d.save === 7 ? '-' : d.save + '+'}/${d.invulnSave ? d.invulnSave + '++' : '-'} W${d.wounds}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function generateDetailedAnalytics() {
            const analyticsContainer = document.getElementById('detailed-analytics');
            if (!analyticsContainer) return;
            
            const { statistics, combatResults } = currentResults;
            
            // Weapon effectiveness analysis
            const weaponAnalysis = Object.entries(statistics.weaponEffectiveness)
                .sort(([,a], [,b]) => b.totalDamage - a.totalDamage)
                .map(([name, stats]) => ({
                    name,
                    ...stats,
                    efficiency: stats.totalHits > 0 ? stats.totalDamage / stats.totalHits : 0
                }));
            
            // Defender survival analysis
            const defenderAnalysis = Object.entries(statistics.defenderSurvival)
                .sort(([,a], [,b]) => a.survivalRate - b.survivalRate)
                .map(([name, stats]) => ({
                    name,
                    ...stats,
                    mortality: (1 - stats.survivalRate) * 100
                }));
            
            // Combat matrix for detailed matchup analysis
            const combatMatrix = generateCombatMatrix(combatResults);
            
            analyticsContainer.innerHTML = `
                <div class="analytics-section">
                    <h4><i class="material-icons" aria-hidden="true">assessment</i> Waffen-Effektivität</h4>
                    <div class="weapon-analysis">
                        ${weaponAnalysis.map(weapon => `
                            <div class="analysis-row">
                                <div class="analysis-header">
                                    <span class="analysis-name">${weapon.name}</span>
                                    <span class="analysis-score">${weapon.totalDamage.toLocaleString()} Schaden</span>
                                </div>
                                <div class="analysis-details">
                                    <div class="detail-item">
                                        <span class="detail-label">Effizienz:</span>
                                        <span class="detail-value">${weapon.efficiency.toFixed(2)} Schaden/Treffer</span>
                                    </div>
                                    <div class="detail-item">
                                        <span class="detail-label">Trefferquote:</span>
                                        <span class="detail-value">${(weapon.hitRate * 100).toFixed(1)}%</span>
                                    </div>
                                    <div class="detail-item">
                                        <span class="detail-label">Gesamttreffer:</span>
                                        <span class="detail-value">${weapon.totalHits.toLocaleString()}</span>
                                    </div>
                                </div>
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${(weapon.totalDamage / weaponAnalysis[0].totalDamage) * 100}%"></div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div class="analytics-section">
                    <h4><i class="material-icons" aria-hidden="true">shield</i> Verteidiger-Überlebenschancen</h4>
                    <div class="defender-analysis">
                        ${defenderAnalysis.map(defender => `
                            <div class="analysis-row">
                                <div class="analysis-header">
                                    <span class="analysis-name">${defender.name}</span>
                                    <span class="analysis-score mortality">${defender.mortality.toFixed(1)}% Sterblichkeit</span>
                                </div>
                                <div class="analysis-details">
                                    <div class="detail-item">
                                        <span class="detail-label">Überlebenschance:</span>
                                        <span class="detail-value">${(defender.survivalRate * 100).toFixed(1)}%</span>
                                    </div>
                                    <div class="detail-item">
                                        <span class="detail-label">Ø LP verbleibend:</span>
                                        <span class="detail-value">${defender.averageWoundsRemaining.toFixed(1)}</span>
                                    </div>
                                    <div class="detail-item">
                                        <span class="detail-label">Schaden erhalten:</span>
                                        <span class="detail-value">${defender.damageReceived.toLocaleString()}</span>
                                    </div>
                                </div>
                                <div class="progress-bar survival">
                                    <div class="progress-fill" style="width: ${defender.survivalRate * 100}%"></div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div class="analytics-section">
                    <h4><i class="material-icons" aria-hidden="true">grid_on</i> Kampf-Matrix</h4>
                    <div class="combat-matrix-container">
                        ${combatMatrix}
                    </div>
                </div>
            `;
        }
        
        function generateCombatMatrix(combatResults) {
            // Create a matrix showing weapon vs defender effectiveness
            const weapons = [...new Set(combatResults.map(r => r.weapon))];
            const defenders = [...new Set(combatResults.map(r => r.defender))];
            
            // Find max damage for normalization
            const maxDamage = Math.max(...combatResults.map(r => r.totalDamage));
            
            let matrix = `
                <table class="combat-matrix">
                    <thead>
                        <tr>
                            <th class="matrix-corner">Waffe vs Ziel</th>
                            ${defenders.map(d => `<th class="defender-header">${d}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            weapons.forEach(weapon => {
                matrix += `<tr><td class="weapon-header">${weapon}</td>`;
                
                defenders.forEach(defender => {
                    const result = combatResults.find(r => r.weapon === weapon && r.defender === defender);
                    if (result) {
                        const intensity = (result.totalDamage / maxDamage) * 100;
                        const killRate = (result.killCount / currentResults.iterations) * 100;
                        
                        matrix += `
                            <td class="matrix-cell" style="background: linear-gradient(45deg, rgba(244, 67, 54, ${intensity/100}) 0%, rgba(255, 152, 0, ${intensity/100}) 100%)">
                                <div class="cell-damage">${result.totalDamage.toLocaleString()}</div>
                                <div class="cell-kills">${killRate.toFixed(1)}% Kills</div>
                            </td>
                        `;
                    } else {
                        matrix += `<td class="matrix-cell empty">-</td>`;
                    }
                });
                
                matrix += `</tr>`;
            });
            
            matrix += `</tbody></table>`;
            return matrix;
        }
        
        function generateDataVisualization() {
            const chartsContainer = document.getElementById('data-visualization');
            if (!chartsContainer) return;
            
            const { combatResults, statistics } = currentResults;
            
            // Generate damage distribution chart
            const damageChart = generateDamageDistributionChart(combatResults);
            
            // Generate hit rate comparison chart
            const hitRateChart = generateHitRateChart(statistics.weaponEffectiveness);
            
            // Generate survival rate chart
            const survivalChart = generateSurvivalChart(statistics.defenderSurvival);
            
            chartsContainer.innerHTML = `
                <div class="charts-grid">
                    <div class="chart-container">
                        <h4><i class="material-icons" aria-hidden="true">bar_chart</i> Schadensverteilung</h4>
                        <div class="chart-content">
                            ${damageChart}
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <h4><i class="material-icons" aria-hidden="true">pie_chart</i> Trefferquoten-Vergleich</h4>
                        <div class="chart-content">
                            ${hitRateChart}
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <h4><i class="material-icons" aria-hidden="true">donut_small</i> Überlebensraten</h4>
                        <div class="chart-content">
                            ${survivalChart}
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <h4><i class="material-icons" aria-hidden="true">timeline</i> Kampfverlauf-Analyse</h4>
                        <div class="chart-content">
                            ${generateBattleProgressChart(combatResults)}
                        </div>
                    </div>
                </div>
            `;
        }
        
        function generateDamageDistributionChart(combatResults) {
            const maxDamage = Math.max(...combatResults.map(r => r.totalDamage));
            const sorted = [...combatResults].sort((a, b) => b.totalDamage - a.totalDamage);
            
            return `
                <div class="bar-chart">
                    ${sorted.slice(0, 10).map((result, index) => {
                        const percentage = (result.totalDamage / maxDamage) * 100;
                        return `
                            <div class="bar-item">
                                <div class="bar-label">${result.weapon} → ${result.defender}</div>
                                <div class="bar-container">
                                    <div class="bar-fill" style="width: ${percentage}%"></div>
                                    <span class="bar-value">${result.totalDamage.toLocaleString()}</span>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }
        
        function generateHitRateChart(weaponEffectiveness) {
            const weapons = Object.entries(weaponEffectiveness);
            const maxHitRate = Math.max(...weapons.map(([,stats]) => stats.hitRate));
            
            return `
                <div class="pie-chart-container">
                    <div class="pie-chart">
                        ${weapons.map(([name, stats], index) => {
                            const angle = (stats.hitRate / maxHitRate) * 360;
                            const hue = (index * 360) / weapons.length;
                            return `
                                <div class="pie-slice" style="--angle: ${angle}deg; --color: hsl(${hue}, 70%, 60%);">
                                    <span class="pie-label">${name}: ${(stats.hitRate * 100).toFixed(1)}%</span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <div class="pie-legend">
                        ${weapons.map(([name, stats], index) => {
                            const hue = (index * 360) / weapons.length;
                            return `
                                <div class="legend-item">
                                    <div class="legend-color" style="background: hsl(${hue}, 70%, 60%);"></div>
                                    <span>${name} (${(stats.hitRate * 100).toFixed(1)}%)</span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
        }
        
        function generateSurvivalChart(defenderSurvival) {
            const defenders = Object.entries(defenderSurvival);
            
            return `
                <div class="survival-chart">
                    ${defenders.map(([name, stats]) => {
                        const survivalPercentage = stats.survivalRate * 100;
                        const mortalityPercentage = 100 - survivalPercentage;
                        
                        return `
                            <div class="survival-item">
                                <div class="survival-header">
                                    <span class="survival-name">${name}</span>
                                    <span class="survival-rate">${survivalPercentage.toFixed(1)}%</span>
                                </div>
                                <div class="survival-bar">
                                    <div class="survival-fill" style="width: ${survivalPercentage}%"></div>
                                    <div class="mortality-fill" style="width: ${mortalityPercentage}%"></div>
                                </div>
                                <div class="survival-details">
                                    <small>Ø ${stats.averageWoundsRemaining.toFixed(1)} LP verbleibend</small>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }
        
        function generateBattleProgressChart(combatResults) {
            // Create a timeline showing damage accumulation
            const sortedByDamage = [...combatResults].sort((a, b) => b.totalDamage - a.totalDamage);
            const maxDamage = sortedByDamage[0].totalDamage;
            
            return `
                <div class="timeline-chart">
                    <div class="timeline-axis">
                        ${sortedByDamage.map((result, index) => {
                            const position = (index / (sortedByDamage.length - 1)) * 100;
                            const height = (result.totalDamage / maxDamage) * 100;
                            
                            return `
                                <div class="timeline-point" style="left: ${position}%; height: ${height}%;">
                                    <div class="timeline-tooltip">
                                        <strong>${result.weapon}</strong><br>
                                        vs ${result.defender}<br>
                                        ${result.totalDamage.toLocaleString()} Schaden<br>
                                        ${((result.killCount / currentResults.iterations) * 100).toFixed(1)}% Kills
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <div class="timeline-labels">
                        <span>Niedrigster Schaden</span>
                        <span>Höchster Schaden</span>
                    </div>
                </div>
            `;
        }
        
        function generateExportOptions() {
            const exportContainer = document.getElementById('export-options');
            if (!exportContainer) return;
            
            exportContainer.innerHTML = `
                <div class="export-section">
                    <h4><i class="material-icons" aria-hidden="true">file_download</i> Export & Berichte</h4>
                    
                    <div class="export-grid">
                        <div class="export-option">
                            <button class="btn btn-primary" onclick="exportResultsPDF()">
                                <i class="material-icons" aria-hidden="true">picture_as_pdf</i>
                                <span>PDF-Bericht</span>
                            </button>
                            <p class="export-description">Vollständiger Bericht mit allen Analysen und Diagrammen</p>
                        </div>
                        
                        <div class="export-option">
                            <button class="btn btn-secondary" onclick="exportResultsJSON()">
                                <i class="material-icons" aria-hidden="true">code</i>
                                <span>JSON-Daten</span>
                            </button>
                            <p class="export-description">Rohdaten für weitere Analysen</p>
                        </div>
                        
                        <div class="export-option">
                            <button class="btn btn-secondary" onclick="exportResultsCSV()">
                                <i class="material-icons" aria-hidden="true">table_chart</i>
                                <span>CSV-Tabelle</span>
                            </button>
                            <p class="export-description">Tabellarische Daten für Excel/Calc</p>
                        </div>
                        
                        <div class="export-option">
                            <button class="btn btn-secondary" onclick="shareResults()">
                                <i class="material-icons" aria-hidden="true">share</i>
                                <span>Teilen</span>
                            </button>
                            <p class="export-description">Link oder Code zum Teilen generieren</p>
                        </div>
                    </div>
                    
                    <div class="export-summary">
                        <div class="summary-stat">
                            <i class="material-icons" aria-hidden="true">storage</i>
                            <span>Dateigröße: ~${Math.round(JSON.stringify(currentResults).length / 1024)} KB</span>
                        </div>
                        <div class="summary-stat">
                            <i class="material-icons" aria-hidden="true">schedule</i>
                            <span>Erstellt: ${new Date(currentResults.timestamp).toLocaleString()}</span>
                        </div>
                        <div class="summary-stat">
                            <i class="material-icons" aria-hidden="true">repeat</i>
                            <span>${currentResults.iterations.toLocaleString()} Simulationen</span>
                        </div>
                    </div>
                </div>
            `;
        }
        
        async function exportResultsPDF() {
            if (!currentResults) {
                showErrorToast('Keine Ergebnisse zum Exportieren verfügbar');
                return;
            }
            
            showLoadingOverlay('PDF-Bericht wird erstellt...');
            
            try {
                // This would require jsPDF library integration
                const { jsPDF } = window.jspdf || {};
                if (!jsPDF) {
                    throw new Error('PDF-Bibliothek nicht verfügbar');
                }
                
                const doc = new jsPDF();
                
                // Add title
                doc.setFontSize(20);
                doc.text('Warhammer 40k Kampfsimulation - Bericht', 20, 20);
                
                // Add timestamp
                doc.setFontSize(12);
                doc.text(`Erstellt: ${new Date(currentResults.timestamp).toLocaleString()}`, 20, 35);
                doc.text(`Iterationen: ${currentResults.iterations.toLocaleString()}`, 20, 45);
                
                // Add summary statistics
                doc.setFontSize(16);
                doc.text('Zusammenfassung', 20, 65);
                doc.setFontSize(12);
                doc.text(`Gesamtschaden: ${currentResults.statistics.totalDamageDealt.toLocaleString()}`, 20, 80);
                doc.text(`Treffer: ${currentResults.statistics.totalHits.toLocaleString()} / ${currentResults.statistics.totalAttacks.toLocaleString()}`, 20, 90);
                
                // Add weapon effectiveness
                let yPos = 110;
                doc.setFontSize(16);
                doc.text('Waffen-Effektivität', 20, yPos);
                yPos += 15;
                
                Object.entries(currentResults.statistics.weaponEffectiveness).forEach(([name, stats]) => {
                    doc.setFontSize(10);
                    doc.text(`${name}: ${stats.totalDamage.toLocaleString()} Schaden, ${(stats.hitRate * 100).toFixed(1)}% Treffer`, 25, yPos);
                    yPos += 10;
                });
                
                // Save the PDF
                const filename = `warhammer-simulation-${new Date().toISOString().slice(0, 10)}.pdf`;
                doc.save(filename);
                
                announceToScreenReader('PDF-Bericht erfolgreich erstellt');
                
            } catch (error) {
                console.error('PDF export error:', error);
                showErrorToast(`Fehler beim PDF-Export: ${error.message}`);
            } finally {
                hideLoadingOverlay();
            }
        }
        
        function exportResultsJSON() {
            if (!currentResults) {
                showErrorToast('Keine Ergebnisse zum Exportieren verfügbar');
                return;
            }
            
            const dataStr = JSON.stringify(currentResults, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const filename = `warhammer-simulation-${new Date().toISOString().slice(0, 10)}.json`;
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            
            URL.revokeObjectURL(url);
            announceToScreenReader('JSON-Daten erfolgreich exportiert');
        }
        
        function exportResultsCSV() {
            if (!currentResults) {
                showErrorToast('Keine Ergebnisse zum Exportieren verfügbar');
                return;
            }
            
            // Create CSV data
            const headers = ['Waffe', 'Ziel', 'Gesamtschaden', 'Treffer', 'Angriffe', 'Trefferquote', 'Kills', 'Überlebensrate'];
            const rows = currentResults.combatResults.map(result => [
                result.weapon,
                result.defender,
                result.totalDamage,
                result.totalHits,
                result.totalAttacks,
                ((result.totalHits / result.totalAttacks) * 100).toFixed(2) + '%',
                result.killCount,
                (result.survivalRate * 100).toFixed(2) + '%'
            ]);
            
            const csvContent = [headers, ...rows].map(row => row.join(',')).join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const filename = `warhammer-simulation-${new Date().toISOString().slice(0, 10)}.csv`;
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            
            URL.revokeObjectURL(url);
            announceToScreenReader('CSV-Daten erfolgreich exportiert');
        }
        
        function shareResults() {
            if (!currentResults) {
                showErrorToast('Keine Ergebnisse zum Teilen verfügbar');
                return;
            }
            
            // Create a shareable summary
            const summary = {
                timestamp: currentResults.timestamp,
                iterations: currentResults.iterations,
                totalDamage: currentResults.statistics.totalDamageDealt,
                totalHits: currentResults.statistics.totalHits,
                totalAttacks: currentResults.statistics.totalAttacks,
                weapons: currentResults.weapons.map(w => w.name),
                defenders: currentResults.defenders.map(d => d.name)
            };
            
            const shareText = `🎲 Warhammer 40k Kampfsimulation\n\n` +
                `📊 ${summary.iterations.toLocaleString()} Iterationen\n` +
                `⚔️ ${summary.totalDamage.toLocaleString()} Gesamtschaden\n` +
                `🎯 ${((summary.totalHits / summary.totalAttacks) * 100).toFixed(1)}% Trefferquote\n\n` +
                `Waffen: ${summary.weapons.join(', ')}\n` +
                `Ziele: ${summary.defenders.join(', ')}\n\n` +
                `Erstellt: ${new Date(summary.timestamp).toLocaleString()}`;
            
            if (navigator.share) {
                navigator.share({
                    title: 'Warhammer 40k Kampfsimulation',
                    text: shareText
                }).then(() => {
                    announceToScreenReader('Ergebnisse erfolgreich geteilt');
                }).catch(err => {
                    console.error('Share error:', err);
                    fallbackShare(shareText);
                });
            } else {
                fallbackShare(shareText);
            }
        }
        
        function fallbackShare(text) {
            // Copy to clipboard as fallback
            navigator.clipboard.writeText(text).then(() => {
                showSuccessToast('Ergebnisse in die Zwischenablage kopiert');
                announceToScreenReader('Text in die Zwischenablage kopiert');
            }).catch(err => {
                console.error('Clipboard error:', err);
                showErrorToast('Fehler beim Kopieren in die Zwischenablage');
            });
        }
        
        function showSuccessToast(message) {
            // Create a success toast (similar to error toast but green)
            const toast = document.createElement('div');
            toast.className = 'toast success-toast';
            toast.innerHTML = `
                <div class="toast-content">
                    <i class="material-icons" aria-hidden="true">check_circle</i>
                    <span>${message}</span>
                    <button class="toast-close" onclick="this.parentElement.parentElement.remove()">
                        <i class="material-icons" aria-hidden="true">close</i>
                    </button>
                </div>
            `;
            
            document.body.appendChild(toast);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (toast.parentElement) {
                    toast.remove();
                }
            }, 3000);
        }

        // ===== NOTIFICATION SYSTEM =====
        
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = `
                <div class="notification-content">
                    <i class="material-icons notification-icon">${getNotificationIcon(type)}</i>
                    <span class="notification-message">${message}</span>
                </div>
                <button class="notification-close" onclick="this.parentElement.remove()">
                    <i class="material-icons">close</i>
                </button>
            `;
            
            // Add to page
            let container = document.getElementById('notification-container');
            if (!container) {
                container = document.createElement('div');
                container.id = 'notification-container';
                container.className = 'notification-container';
                document.body.appendChild(container);
            }
            
            container.appendChild(notification);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 5000);
            
            // Announce to screen reader
            announceToScreenReader(message);
        }
        
        function getNotificationIcon(type) {
            switch (type) {
                case 'success': return 'check_circle';
                case 'warning': return 'warning';
                case 'error': return 'error';
                default: return 'info';
            }
        }
        
        // ===== ACCESSIBILITY HELPERS =====
        
        function announceToScreenReader(message) {
            const announcement = document.createElement('div');
            announcement.setAttribute('aria-live', 'polite');
            announcement.setAttribute('aria-atomic', 'true');
            announcement.className = 'sr-only';
            announcement.textContent = message;
            document.body.appendChild(announcement);
            
            setTimeout(() => {
                document.body.removeChild(announcement);
            }, 1000);
        }

        function showErrorToast(message) {
            const toast = document.getElementById('error-toast');
            const messageElement = document.getElementById('error-message');
            messageElement.textContent = message;
            toast.style.display = 'block';
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                hideErrorToast();
            }, 5000);
            
            announceToScreenReader(`Fehler: ${message}`);
        }

        function hideErrorToast() {
            const toast = document.getElementById('error-toast');
            toast.style.display = 'none';
        }

        function showLoadingOverlay(message = 'Wird geladen...') {
            const overlay = document.getElementById('loading-overlay');
            const progressElement = document.getElementById('loading-progress');
            progressElement.textContent = message;
            overlay.style.display = 'flex';
            
            // Focus management
            const previousFocus = document.activeElement;
            overlay.setAttribute('data-previous-focus', previousFocus.id || '');
            overlay.focus();
        }

        function hideLoadingOverlay() {
            const overlay = document.getElementById('loading-overlay');
            overlay.style.display = 'none';
            
            // Restore focus
            const previousFocusId = overlay.getAttribute('data-previous-focus');
            if (previousFocusId) {
                const previousElement = document.getElementById(previousFocusId);
                if (previousElement) {
                    previousElement.focus();
                }
            }
        }

        // ===== FORM VALIDATION =====
        
        function initializeRequiredFields() {
            const requiredFields = document.querySelectorAll('input[required], select[required]');
            
            requiredFields.forEach(field => {
                field.addEventListener('input', validateField);
                field.addEventListener('change', validateField);
                field.addEventListener('blur', validateField);
                
                // Initial check
                validateField({ target: field });
            });
            
            updateSimulateButtonState();
        }
        
        function validateField(event) {
            const field = event.target;
            const formGroup = field.closest('.form-group');
            
            if (field.checkValidity()) {
                formGroup?.classList.remove('has-error');
                formGroup?.classList.add('has-success');
            } else {
                formGroup?.classList.remove('has-success');
                formGroup?.classList.add('has-error');
            }
            
            updateSimulateButtonState();
        }

        function updateSimulateButtonState() {
            const btn = document.getElementById('simulate-btn');
            const hasWeapons = selectedWeapons.length > 0;
            const hasDefenders = selectedDefenders.length > 0;
            
            btn.disabled = !(hasWeapons && hasDefenders);
            
            if (btn.disabled) {
                btn.setAttribute('aria-describedby', 'simulate-help');
            } else {
                btn.removeAttribute('aria-describedby');
            }
        }

        // ===== FILE LOADING =====
        
        async function loadWeapons(event) {
            const file = event.target.files[0];
            if (!file) return;

            showLoadingOverlay('Lade Waffendaten...');
            
            try {
                const text = await file.text();
                weaponsData = JSON.parse(text);
                
                if (!Array.isArray(weaponsData) || weaponsData.length === 0) {
                    throw new Error('Ungültige Waffendatei: Keine Waffen gefunden');
                }

                populateWeaponSelect();
                announceToScreenReader(`${weaponsData.length} Waffen erfolgreich geladen`);
                
            } catch (error) {
                console.error('Error loading weapons:', error);
                showErrorToast(`Fehler beim Laden der Waffendatei: ${error.message}`);
                weaponsData = [];
            } finally {
                hideLoadingOverlay();
                updateSimulateButtonState();
            }
        }

        async function loadDefenders(event) {
            const file = event.target.files[0];
            if (!file) return;

            showLoadingOverlay('Lade Verteidigerdaten...');
            
            try {
                const text = await file.text();
                defendersData = JSON.parse(text);
                
                if (!Array.isArray(defendersData) || defendersData.length === 0) {
                    throw new Error('Ungültige Verteidigerdatei: Keine Verteidiger gefunden');
                }

                populateDefenderSelect();
                announceToScreenReader(`${defendersData.length} Verteidiger erfolgreich geladen`);
                
            } catch (error) {
                console.error('Error loading defenders:', error);
                showErrorToast(`Fehler beim Laden der Verteidigerdatei: ${error.message}`);
                defendersData = [];
            } finally {
                hideLoadingOverlay();
                updateSimulateButtonState();
            }
        }

        function populateWeaponSelect() {
            const select = document.getElementById('weapon-select');
            select.innerHTML = '<option value="">-- Waffe auswählen --</option>';
            
            weaponsData.forEach((weapon, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = weapon.name || `Waffe ${index + 1}`;
                select.appendChild(option);
            });
            
            select.disabled = false;
        }

        function populateDefenderSelect() {
            const select = document.getElementById('defender-select');
            select.innerHTML = '<option value="">-- Verteidiger auswählen --</option>';
            
            defendersData.forEach((defender, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = defender.name || `Verteidiger ${index + 1}`;
                select.appendChild(option);
            });
            
            select.disabled = false;
        }

        // ===== BATTLESCRIBE PARSER =====
        
        function parseBattleScribeFile(jsonData) {
            console.log('Parsing BattleScribe roster data...');
            console.log('Available JSON properties:', Object.keys(jsonData));
            
            try {
                let roster = jsonData.roster || jsonData;
                let selections = [];
                
                // Try different ways to find selections
                if (roster && roster.forces && roster.forces[0] && roster.forces[0].selections) {
                    selections = roster.forces[0].selections;
                } else if (roster && roster.selections) {
                    selections = roster.selections;
                } else if (jsonData.forces && jsonData.forces[0] && jsonData.forces[0].selections) {
                    selections = jsonData.forces[0].selections;
                } else if (jsonData.selections) {
                    selections = jsonData.selections;
                } else {
                    console.warn('No selections found, using empty array');
                    selections = [];
                }
                
                console.log(`Found ${selections.length} selections to parse`);
                
                const weapons = [];
                const defenders = [];
                
                // Durchsuche alle Einheiten in der Armee
                function parseSelections(selections, parentName = '') {
                    if (!selections || !Array.isArray(selections)) return;
                    
                    selections.forEach(selection => {
                        // Prüfe ob es eine Einheit ist
                        if (selection.type === 'unit' || selection.type === 'model') {
                            parseUnit(selection, parentName);
                        }
                        
                        // Rekursiv durch Unterauswahlen
                        if (selection.selections) {
                            parseSelections(selection.selections, selection.name || parentName);
                        }
                    });
                }
                
                function parseUnit(unit, parentName) {
                    // Extrahiere Verteidiger-Stats aus Profilen
                    if (unit.profiles) {
                        unit.profiles.forEach(profile => {
                            if (profile.typeName === 'Unit') {
                                const defender = parseDefenderProfile(profile, unit.name, parentName);
                                if (defender) {
                                    defenders.push(defender);
                                }
                            }
                        });
                    }
                    
                    // Extrahiere Waffen
                    if (unit.selections) {
                        unit.selections.forEach(selection => {
                            if (selection.profiles) {
                                selection.profiles.forEach(profile => {
                                    if (profile.typeName === 'Ranged Weapons' || profile.typeName === 'Melee Weapons') {
                                        const weapon = parseWeaponProfile(profile, unit.name, parentName);
                                        if (weapon) {
                                            weapons.push(weapon);
                                        }
                                    }
                                });
                            }
                        });
                    }
                }
                
                function parseDefenderProfile(profile, unitName, parentName) {
                    if (!profile.characteristics) return null;
                    
                    const stats = {};
                    profile.characteristics.forEach(char => {
                        stats[char.name] = char.$text || char.value;
                    });
                    
                    // Standard 40k Statskonvertierung
                    return {
                        id: `defender_${Date.now()}_${Math.random()}`,
                        name: unitName || profile.name,
                        type: determineUnitType(unitName),
                        movement: stats.M || '6"',
                        toughness: parseInt(stats.T) || 4,
                        save: parseInt(stats.SV?.replace('+', '')) || 3,
                        wounds: parseInt(stats.W) || 1,
                        leadership: parseInt(stats.LD?.replace('+', '')) || 6,
                        objectiveControl: parseInt(stats.OC) || 1,
                        invulnSave: null, // Wird aus Abilities extrahiert
                        feelNoPain: null, // Wird aus Abilities extrahiert
                        keywords: extractKeywordsFromUnit(unitName, parentName)
                    };
                }
                
                function parseWeaponProfile(profile, unitName, parentName) {
                    if (!profile.characteristics) return null;
                    
                    const stats = {};
                    profile.characteristics.forEach(char => {
                        stats[char.name] = char.$text || char.value;
                    });
                    
                    // Bestimme Waffentyp
                    const weaponType = profile.typeName === 'Ranged Weapons' ? 'Ranged' : 'Melee';
                    
                    return {
                        id: `weapon_${Date.now()}_${Math.random()}`,
                        name: profile.name || `${unitName} Weapon`,
                        type: weaponType,
                        range: stats.Range || (weaponType === 'Melee' ? 'Melee' : '24"'),
                        attacks: stats.A || '1',
                        skill: parseInt(stats.BS || stats.WS?.replace('+', '')) || 4,
                        strength: parseInt(stats.S) || 4,
                        ap: parseInt(stats.AP?.replace('-', '')) || 0,
                        damage: stats.D || '1',
                        keywords: stats.Keywords || '',
                        unitName: unitName,
                        parentName: parentName
                    };
                }
                
                function extractKeywordsFromUnit(unitName, parentName) {
                    // Basis-Keywords basierend auf Einheitenname
                    const keywords = [];
                    
                    if (unitName) {
                        const name = unitName.toLowerCase();
                        
                        // Fraktion Keywords
                        if (name.includes('daemon') || name.includes('bloodthirster') || name.includes('skarbrand')) {
                            keywords.push('DAEMON', 'LEGIONES DAEMONICA');
                        }
                        
                        // Chaos God Keywords
                        if (name.includes('khorne') || name.includes('blood') || name.includes('skarbrand')) {
                            keywords.push('KHORNE');
                        }
                        if (name.includes('tzeentch')) {
                            keywords.push('TZEENTCH');
                        }
                        if (name.includes('nurgle')) {
                            keywords.push('NURGLE');
                        }
                        if (name.includes('slaanesh')) {
                            keywords.push('SLAANESH');
                        }
                        
                        // Unit Type Keywords
                        if (name.includes('character')) {
                            keywords.push('CHARACTER');
                        }
                        if (name.includes('monster')) {
                            keywords.push('MONSTER');
                        }
                        if (name.includes('vehicle')) {
                            keywords.push('VEHICLE');
                        }
                        
                        keywords.push('CHAOS');
                    }
                    
                    return keywords.join(', ');
                }
                
                function parseWeaponSelections(selections, unitName) {
                    selections.forEach(selection => {
                        if (selection.profiles) {
                            selection.profiles.forEach(profile => {
                                if (profile.typeName === 'Ranged Weapons' || profile.typeName === 'Melee Weapons') {
                                    const weapon = parseWeaponProfile(profile, unitName);
                                    if (weapon) {
                                        weapons.push(weapon);
                                    }
                                }
                            });
                        }
                        
                        // Rekursiv durch Waffenauswahlen
                        if (selection.selections) {
                            parseWeaponSelections(selection.selections, unitName);
                        }
                    });
                }
                
                function parseWeaponSelections(selections, unitName) {
                    selections.forEach(selection => {
                        if (selection.profiles) {
                            selection.profiles.forEach(profile => {
                                if (profile.typeName === 'Ranged Weapons' || profile.typeName === 'Melee Weapons') {
                                    const weapon = parseWeaponProfile(profile, unitName);
                                    if (weapon) {
                                        weapons.push(weapon);
                                    }
                                }
                            });
                        }
                        
                        if (selection.selections) {
                            parseWeaponSelections(selection.selections, unitName);
                        }
                    });
                }
                
                function parseDefenderProfile(profile, unitName, parentName) {
                    const characteristics = {};
                    
                    if (profile.characteristics) {
                        profile.characteristics.forEach(char => {
                            characteristics[char.name] = char.$text || char.value;
                        });
                    }
                    
                    // Warhammer 40k Stats zu unserem Format konvertieren
                    const toughness = parseInt(characteristics.T) || 4;
                    const save = characteristics.SV ? parseInt(characteristics.SV.replace('+', '')) : 7;
                    const wounds = parseInt(characteristics.W) || 1;
                    
                    return {
                        id: Date.now() + Math.random(),
                        name: `${unitName} (${parentName || 'BattleScribe'})`,
                        toughness: toughness,
                        save: save,
                        invulnSave: null, // Wird aus Abilities extrahiert
                        wounds: wounds,
                        feelNoPain: null, // Wird aus Abilities extrahiert
                        type: determineUnitType(unitName),
                        isBattleScribe: true,
                        originalUnit: unitName
                    };
                }
                
                function parseWeaponProfile(profile, unitName) {
                    const characteristics = {};
                    
                    if (profile.characteristics) {
                        profile.characteristics.forEach(char => {
                            characteristics[char.name] = char.$text || char.value;
                        });
                    }
                    
                    // Warhammer 40k Waffen-Stats zu unserem Format konvertieren
                    const attacks = characteristics.A || '1';
                    const skill = characteristics.BS || characteristics.WS || '4+';
                    const strength = parseInt(characteristics.S) || 4;
                    const ap = Math.abs(parseInt(characteristics.AP) || 0);
                    const damage = characteristics.D || '1';
                    const range = characteristics.Range || 'Melee';
                    
                    // Bestimme Waffentyp
                    const weaponType = profile.typeName === 'Melee Weapons' ? 'Melee' : 'Ranged';
                    
                    return {
                        id: Date.now() + Math.random(),
                        name: `${profile.name} (${unitName})`,
                        attacks: attacks,
                        skill: parseInt(skill.replace('+', '')) || 4,
                        strength: strength,
                        ap: ap,
                        damage: damage,
                        type: weaponType,
                        range: range,
                        keywords: characteristics.Keywords || '',
                        isBattleScribe: true,
                        originalWeapon: profile.name,
                        originalUnit: unitName
                    };
                }
                
                function determineUnitType(unitName) {
                    const name = unitName.toLowerCase();
                    
                    if (name.includes('vehicle') || name.includes('tank') || name.includes('dreadnought')) {
                        return 'Vehicle';
                    } else if (name.includes('monster') || name.includes('daemon')) {
                        return 'Monster';
                    } else if (name.includes('captain') || name.includes('sergeant') || name.includes('lieutenant') || name.includes('chaplain') || name.includes('librarian')) {
                        return 'Character';
                    } else {
                        return 'Infantry';
                    }
                }
                
                // Parse die Hauptstruktur
                parseSelections(selections);
                
                console.log(`BattleScribe Parser: ${weapons.length} Waffen und ${defenders.length} Verteidiger gefunden`);
                
                // Flexiblere Extraktion der Roster-Informationen
                let rosterName = 'BattleScribe Roster';
                let gameSystem = 'Warhammer 40,000';
                let points = 0;
                
                if (roster && roster.name) {
                    rosterName = roster.name;
                } else if (jsonData.name) {
                    rosterName = jsonData.name;
                }
                
                if (jsonData.gameSystemName) {
                    gameSystem = jsonData.gameSystemName;
                } else if (roster && roster.gameSystemName) {
                    gameSystem = roster.gameSystemName;
                }
                
                if (roster && roster.costs) {
                    const pointsCost = roster.costs.find(c => c.name === 'pts' || c.name === 'points');
                    points = pointsCost ? pointsCost.value : 0;
                }
                
                return {
                    weapons: weapons,
                    defenders: defenders,
                    rosterName: rosterName,
                    gameSystem: gameSystem,
                    points: points
                };
                
            } catch (error) {
                console.error('BattleScribe Parser Error:', error);
                throw new Error(`Fehler beim Parsen der BattleScribe-Datei: ${error.message}`);
            }
        }
        
        function loadBattleScribeFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            showLoadingOverlay('Lade BattleScribe-Roster...');
            
            const fileReader = new FileReader();
            fileReader.onload = async function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    
                    // Prüfe ob es eine BattleScribe-Datei ist
                    if (!jsonData.roster || !jsonData.gameSystemName) {
                        throw new Error('Dies ist keine gültige BattleScribe-Roster-Datei');
                    }
                    
                    const parsedData = parseBattleScribeFile(jsonData);
                    
                    // Füge die geparsten Daten zu den globalen Arrays hinzu
                    if (parsedData.weapons.length > 0) {
                        weaponsData = [...weaponsData, ...parsedData.weapons];
                        populateWeaponSelect();
                        announceToScreenReader(`${parsedData.weapons.length} Waffen aus BattleScribe-Roster geladen`);
                    }
                    
                    if (parsedData.defenders.length > 0) {
                        defendersData = [...defendersData, ...parsedData.defenders];
                        populateDefenderSelect();
                        announceToScreenReader(`${parsedData.defenders.length} Verteidiger aus BattleScribe-Roster geladen`);
                    }
                    
                    // Zeige Erfolgsmeldung
                    showBattleScribeSuccessMessage(parsedData);
                    
                } catch (error) {
                    console.error('Error loading BattleScribe file:', error);
                    showErrorToast(`Fehler beim Laden der BattleScribe-Datei: ${error.message}`);
                } finally {
                    hideLoadingOverlay();
                    updateSimulateButtonState();
                }
            };
            
            fileReader.readAsText(file);
        }
        
        function showBattleScribeSuccessMessage(parsedData) {
            const message = `
                <div style="background: var(--success-color); color: white; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                    <h4 style="margin: 0 0 0.5rem 0;">✅ BattleScribe-Roster erfolgreich geladen!</h4>
                    <p style="margin: 0; font-size: 0.9rem;">
                        <strong>${parsedData.rosterName}</strong><br>
                        ${parsedData.weapons.length} Waffen und ${parsedData.defenders.length} Verteidiger importiert<br>
                        Armeepunkte: ${parsedData.points} | System: ${parsedData.gameSystem}
                    </p>
                </div>
            `;
            
            // Füge die Nachricht am Anfang der Waffen-Sektion hinzu
            const weaponCard = document.querySelector('.card');
            if (weaponCard) {
                const messageDiv = document.createElement('div');
                messageDiv.innerHTML = message;
                weaponCard.parentNode.insertBefore(messageDiv, weaponCard);
                
                // Entferne die Nachricht nach 10 Sekunden
                setTimeout(() => {
                    messageDiv.remove();
                }, 10000);
            }
        }

        // ===== CUSTOM UNIT CREATION =====
        
        function createCustomWeapon() {
            const name = document.getElementById('weapon-name').value.trim();
            const attacks = document.getElementById('weapon-attacks').value.trim();
            const skill = document.getElementById('weapon-skill').value;
            const strength = document.getElementById('weapon-strength').value;
            const ap = document.getElementById('weapon-ap').value;
            const damage = document.getElementById('weapon-damage').value.trim();
            const type = document.getElementById('weapon-type').value;
            
            // Validation
            if (!name) {
                showErrorToast('Bitte geben Sie einen Waffennamen ein');
                document.getElementById('weapon-name').focus();
                return;
            }
            
            if (!attacks) {
                showErrorToast('Bitte geben Sie die Anzahl Angriffe ein');
                document.getElementById('weapon-attacks').focus();
                return;
            }
            
            if (!damage) {
                showErrorToast('Bitte geben Sie den Schaden ein');
                document.getElementById('weapon-damage').focus();
                return;
            }
            
            // Check if weapon already exists
            if (selectedWeapons.find(w => w.name === name)) {
                showErrorToast('Eine Waffe mit diesem Namen existiert bereits');
                document.getElementById('weapon-name').focus();
                return;
            }
            
            const customWeapon = {
                id: Date.now(),
                name: name,
                attacks: attacks,
                skill: parseInt(skill),
                strength: parseInt(strength),
                ap: parseInt(ap),
                damage: damage,
                type: type,
                isCustom: true
            };
            
            selectedWeapons.push(customWeapon);
            updateSelectedWeaponsDisplay();
            updateSimulateButtonState();
            clearWeaponForm();
            
            announceToScreenReader(`Eigene Waffe ${name} erfolgreich hinzugefügt`);
        }
        
        function createCustomDefender() {
            const name = document.getElementById('defender-name').value.trim();
            const toughness = document.getElementById('defender-toughness').value;
            const save = document.getElementById('defender-save').value;
            const invuln = document.getElementById('defender-invuln').value;
            const wounds = document.getElementById('defender-wounds').value;
            const fnp = document.getElementById('defender-fnp').value;
            const type = document.getElementById('defender-type').value;
            
            // Validation
            if (!name) {
                showErrorToast('Bitte geben Sie einen Verteidigernamen ein');
                document.getElementById('defender-name').focus();
                return;
            }
            
            // Check if defender already exists
            if (selectedDefenders.find(d => d.name === name)) {
                showErrorToast('Ein Verteidiger mit diesem Namen existiert bereits');
                document.getElementById('defender-name').focus();
                return;
            }
            
            const customDefender = {
                id: Date.now(),
                name: name,
                toughness: parseInt(toughness),
                save: parseInt(save),
                invulnSave: invuln ? parseInt(invuln) : null,
                wounds: parseInt(wounds),
                feelNoPain: fnp ? parseInt(fnp) : null,
                type: type,
                isCustom: true
            };
            
            selectedDefenders.push(customDefender);
            updateSelectedDefendersDisplay();
            updateSimulateButtonState();
            clearDefenderForm();
            
            announceToScreenReader(`Eigener Verteidiger ${name} erfolgreich hinzugefügt`);
        }
        
        function clearWeaponForm() {
            document.getElementById('weapon-name').value = '';
            document.getElementById('weapon-attacks').value = '1';
            document.getElementById('weapon-skill').value = '4';
            document.getElementById('weapon-strength').value = '4';
            document.getElementById('weapon-ap').value = '0';
            document.getElementById('weapon-damage').value = '1';
            document.getElementById('weapon-type').value = 'Ranged';
        }
        
        function clearDefenderForm() {
            document.getElementById('defender-name').value = '';
            document.getElementById('defender-toughness').value = '4';
            document.getElementById('defender-save').value = '3';
            document.getElementById('defender-invuln').value = '';
            document.getElementById('defender-wounds').value = '2';
            document.getElementById('defender-fnp').value = '';
            document.getElementById('defender-type').value = 'Infantry';
        }

        // ===== SELECTION FUNCTIONS =====
        
        function selectWeapon() {
            const select = document.getElementById('weapon-select');
            const selectedIndex = select.value;
            
            if (selectedIndex === '') return;
            
            const weapon = weaponsData[selectedIndex];
            if (!weapon) return;
            
            // Check if already selected
            if (selectedWeapons.find(w => w.name === weapon.name)) {
                showErrorToast('Diese Waffe ist bereits ausgewählt');
                select.value = '';
                return;
            }
            
            selectedWeapons.push({ ...weapon, id: Date.now() });
            updateSelectedWeaponsDisplay();
            updateSimulateButtonState();
            select.value = '';
            
            announceToScreenReader(`Waffe ${weapon.name} hinzugefügt`);
        }

        function selectDefender() {
            const select = document.getElementById('defender-select');
            const selectedIndex = select.value;
            
            if (selectedIndex === '') return;
            
            const defender = defendersData[selectedIndex];
            if (!defender) return;
            
            // Check if already selected
            if (selectedDefenders.find(d => d.name === defender.name)) {
                showErrorToast('Dieser Verteidiger ist bereits ausgewählt');
                select.value = '';
                return;
            }
            
            selectedDefenders.push({ ...defender, id: Date.now() });
            updateSelectedDefendersDisplay();
            updateSimulateButtonState();
            select.value = '';
            
            announceToScreenReader(`Verteidiger ${defender.name} hinzugefügt`);
        }

        // ===== DISPLAY FUNCTIONS =====
        
        function updateSelectedWeaponsDisplay() {
            const container = document.getElementById('selected-weapons');
            container.innerHTML = '';
            
            selectedWeapons.forEach(weapon => {
                const weaponCard = createWeaponCard(weapon);
                container.appendChild(weaponCard);
            });
        }

        function updateSelectedDefendersDisplay() {
            const container = document.getElementById('selected-defenders');
            container.innerHTML = '';
            
            selectedDefenders.forEach(defender => {
                const defenderCard = createDefenderCard(defender);
                container.appendChild(defenderCard);
            });
        }

        function createWeaponCard(weapon) {
            const card = document.createElement('div');
            card.className = 'card';
            card.style.marginTop = '1rem';
            card.setAttribute('role', 'article');
            card.setAttribute('aria-labelledby', `weapon-title-${weapon.id}`);
            
            const typeIcon = weapon.type === 'Melee' ? 'sports_martial_arts' : 
                           weapon.type === 'Psychic' ? 'psychology' : 'gps_fixed';
            
            let sourceBadge = '';
            if (weapon.isCustom) {
                sourceBadge = '<span class="badge" style="background: var(--info-color); color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.75rem; margin-left: 8px;">Benutzerdefiniert</span>';
            } else if (weapon.isBattleScribe) {
                sourceBadge = '<span class="badge" style="background: var(--warning-color); color: var(--primary-bg); padding: 2px 8px; border-radius: 12px; font-size: 0.75rem; margin-left: 8px;">BattleScribe</span>';
            }
            
            const rangeInfo = weapon.range && weapon.range !== 'Melee' ? `<div><strong>Reichweite:</strong> ${weapon.range}</div>` : '';
            const keywordsInfo = weapon.keywords ? `<div><strong>Keywords:</strong> ${weapon.keywords}</div>` : '';
            const unitInfo = weapon.originalUnit ? `<div><strong>Einheit:</strong> ${weapon.originalUnit}</div>` : '';
            
            card.innerHTML = `
                <div class="card-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <h4 id="weapon-title-${weapon.id}" class="card-title" style="margin: 0; display: flex; align-items: center;">
                        <i class="material-icons" aria-hidden="true" style="margin-right: 8px;">${typeIcon}</i>
                        ${weapon.name}
                        ${sourceBadge}
                    </h4>
                    <button 
                        class="btn btn-icon btn-danger"
                        onclick="removeWeapon(${weapon.id})"
                        aria-label="Waffe ${weapon.name} entfernen"
                        title="Waffe entfernen"
                    >
                        <i class="material-icons" aria-hidden="true">delete</i>
                    </button>
                </div>
                <div class="card-body">
                    <div class="grid grid-3" style="gap: 1rem;">
                        <div><strong>Angriffe:</strong> ${weapon.attacks}</div>
                        <div><strong>Treffer:</strong> ${weapon.skill}+</div>
                        <div><strong>Stärke:</strong> ${weapon.strength}</div>
                        <div><strong>AP:</strong> -${weapon.ap}</div>
                        <div><strong>Schaden:</strong> ${weapon.damage}</div>
                        <div><strong>Typ:</strong> ${weapon.type}</div>
                        ${rangeInfo}
                        ${unitInfo}
                        ${keywordsInfo}
                    </div>
                </div>
            `;
            
            return card;
        }

        function createDefenderCard(defender) {
            const card = document.createElement('div');
            card.className = 'card';
            card.style.marginTop = '1rem';
            card.setAttribute('role', 'article');
            card.setAttribute('aria-labelledby', `defender-title-${defender.id}`);
            
            const typeIcon = defender.type === 'Vehicle' ? 'directions_car' : 
                           defender.type === 'Monster' ? 'pest_control' : 
                           defender.type === 'Character' ? 'person' : 'groups';
            
            let sourceBadge = '';
            if (defender.isCustom) {
                sourceBadge = '<span class="badge" style="background: var(--info-color); color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.75rem; margin-left: 8px;">Benutzerdefiniert</span>';
            } else if (defender.isBattleScribe) {
                sourceBadge = '<span class="badge" style="background: var(--warning-color); color: var(--primary-bg); padding: 2px 8px; border-radius: 12px; font-size: 0.75rem; margin-left: 8px;">BattleScribe</span>';
            }
            
            const invulnText = defender.invulnSave ? `${defender.invulnSave}++` : 'Keine';
            const fnpText = defender.feelNoPain ? `${defender.feelNoPain}+++` : 'Keine';
            const saveText = defender.save === 7 ? 'Kein RW' : `${defender.save}+`;
            const unitInfo = defender.originalUnit ? `<div><strong>Ursprungseinheit:</strong> ${defender.originalUnit}</div>` : '';
            
            card.innerHTML = `
                <div class="card-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <h4 id="defender-title-${defender.id}" class="card-title" style="margin: 0; display: flex; align-items: center;">
                        <i class="material-icons" aria-hidden="true" style="margin-right: 8px;">${typeIcon}</i>
                        ${defender.name}
                        ${sourceBadge}
                    </h4>
                    <button 
                        class="btn btn-icon btn-danger"
                        onclick="removeDefender(${defender.id})"
                        aria-label="Verteidiger ${defender.name} entfernen"
                        title="Verteidiger entfernen"
                    >
                        <i class="material-icons" aria-hidden="true">delete</i>
                    </button>
                </div>
                <div class="card-body">
                    <div class="grid grid-3" style="gap: 1rem;">
                        <div><strong>Widerstandskraft:</strong> ${defender.toughness}</div>
                        <div><strong>Rettungswurf:</strong> ${saveText}</div>
                        <div><strong>Unverwundbar:</strong> ${invulnText}</div>
                        <div><strong>Lebenspunkte:</strong> ${defender.wounds}</div>
                        <div><strong>Feel No Pain:</strong> ${fnpText}</div>
                        <div><strong>Typ:</strong> ${defender.type}</div>
                        ${unitInfo}
                    </div>
                </div>
            `;
            
            return card;
        }

        function removeWeapon(weaponId) {
            const weapon = selectedWeapons.find(w => w.id === weaponId);
            if (!weapon) return;
            
            selectedWeapons = selectedWeapons.filter(w => w.id !== weaponId);
            updateSelectedWeaponsDisplay();
            updateSimulateButtonState();
            
            announceToScreenReader(`Waffe ${weapon.name} entfernt`);
        }

        function removeDefender(defenderId) {
            const defender = selectedDefenders.find(d => d.id === defenderId);
            if (!defender) return;
            
            selectedDefenders = selectedDefenders.filter(d => d.id !== defenderId);
            updateSelectedDefendersDisplay();
            updateSimulateButtonState();
            
            announceToScreenReader(`Verteidiger ${defender.name} entfernt`);
        }

        // ===== SIMULATION FUNCTIONS =====
        
        async function runSimulation() {
            // Validation
            if (selectedWeapons.length === 0 || selectedDefenders.length === 0) {
                showErrorToast('Bitte wählen Sie mindestens eine Waffe und einen Verteidiger aus');
                return;
            }

            const iterations = parseInt(document.getElementById('iterations').value) || 10000;
            
            if (iterations < 100 || iterations > 1000000) {
                showErrorToast('Anzahl Simulationen muss zwischen 100 und 1.000.000 liegen');
                return;
            }

            showLoadingOverlay('Führe Kampfsimulation durch...');
            
            try {
                // Placeholder simulation
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                const results = {
                    weapons: selectedWeapons,
                    defenders: selectedDefenders,
                    iterations: iterations,
                    timestamp: new Date().toISOString(),
                    message: 'Simulation erfolgreich durchgeführt (Placeholder)'
                };
                
                currentResults = results;
                displayResults(results);
                
                announceToScreenReader('Simulation erfolgreich abgeschlossen');
                
            } catch (error) {
                console.error('Simulation error:', error);
                showErrorToast(`Fehler bei der Simulation: ${error.message}`);
            } finally {
                hideLoadingOverlay();
            }
        }

        function displayResults(results) {
            const resultsSection = document.getElementById('results');
            const resultsContent = document.getElementById('results-content');
            
            resultsContent.innerHTML = `
                <div class="grid grid-2">
                    <div>
                        <h3>Simulation Details</h3>
                        <p><strong>Iterationen:</strong> ${results.iterations.toLocaleString()}</p>
                        <p><strong>Waffen:</strong> ${results.weapons.length}</p>
                        <p><strong>Verteidiger:</strong> ${results.defenders.length}</p>
                        <p><strong>Zeitstempel:</strong> ${new Date(results.timestamp).toLocaleString()}</p>
                    </div>
                    <div>
                        <h3>Ergebnisse</h3>
                        <p>${results.message}</p>
                        <p class="text-muted">Die vollständige Simulation wird in einer zukünftigen Version implementiert.</p>
                    </div>
                </div>
            `;
            
            resultsSection.style.display = 'block';
            resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function clearResults() {
            const resultsSection = document.getElementById('results');
            const resultsContent = document.getElementById('results-content');
            
            resultsContent.innerHTML = '';
            resultsSection.style.display = 'none';
            currentResults = null;
            
            announceToScreenReader('Ergebnisse gelöscht');
        }

        // ===== EXPORT FUNCTIONS =====
        
        async function exportToPDF() {
            if (!currentResults) {
                showErrorToast('Keine Ergebnisse zum Exportieren verfügbar');
                return;
            }

            showLoadingOverlay('Erstelle PDF...');
            
            try {
                // Placeholder PDF export
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                showErrorToast('PDF-Export wird in einer zukünftigen Version implementiert');
                
            } catch (error) {
                console.error('PDF export error:', error);
                showErrorToast(`Fehler beim PDF-Export: ${error.message}`);
            } finally {
                hideLoadingOverlay();
            }
        }

        // ===== KEYBOARD NAVIGATION =====
        
        document.addEventListener('keydown', function(event) {
            // ESC key handling
            if (event.key === 'Escape') {
                const loadingOverlay = document.getElementById('loading-overlay');
                if (loadingOverlay.style.display !== 'none') {
                    hideLoadingOverlay();
                    return;
                }
                
                const errorToast = document.getElementById('error-toast');
                if (errorToast.style.display !== 'none') {
                    hideErrorToast();
                    return;
                }
            }
            
            // Enter key for simulation
            if (event.key === 'Enter' && event.target.id === 'simulate-btn') {
                runSimulation();
            }
        });
    </script>
</body>
</html>
